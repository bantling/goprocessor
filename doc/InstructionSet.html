<!DOCTYPE html>
<!-- SPDX-License-Identifier: Apache-2.0 -->
<html>
  <head>
    <title>Instruction Set</title>
    <style type="text/css">  
      /* FF loads whatever it can first, in the order provided. List ttf first */
      @font-face {
        font-family: "Roboto Mono";
        src: url("roboto-mono.eot");
        src: url("roboto-mono.eot?#iefix") format("embedded-opentype"),
             url("roboto-mono.woff2") format("woff2"),
             url("roboto-mono.woff") format("woff"),
             url("roboto-mono.ttf") format("truetype"),
             url("roboto-mono.svg#webfont") format("svg");
      }
      
      /* Clear spacings */
      * {
        margin: 0;
        padding: 0;
        border: none;
      }
      
      /* Set some defaults */
      body {
        margin: 5px;
        font-family: "Roboto Mono", monospace;
        font-size: 9pt;
      }
      
      /* Every sibling except the first */
      * + * {
        margin-top: 10px;
      }
      
      /* Some browsers apply * + * to <br> tags, some don't */
      br {
        margin: 0;
      }
      
      h1 {
        font-size: 1.4em;
        font-weight: bold;
      }
      
      h2 {
        font-size: 1.2em;
        font-weight: bold;
      }
      
      ol > li {
        margin-left: 2em;
      }
      
      li + li, ol ul {
        margin-top: 0.25em;
      }
      
      ul > li {
        list-style: none;
        margin-left: 1em;
      }
      
      ul > li:before {
        position: relative;
        left: -1.25em;
        top: -0.25em;
        content: "\25CF";
        font-size: 0.75em;
      }
      
      table {
        border-collapse: collapse;
        font-size: 1em;
        font-weight: normal;
      }
      
      th, td {
        border: 1px solid black;
        padding: 2px 5px;
        white-space: nowrap;
      }
      
      th {
        font-weight: bold;
        text-align: center;
      }
      
      /* Table cells that show the header for a group of rows */
      td[colspan="4"] {
        font-weight: bold;
        padding: 10px 5px;
      }
      
      /* the pre class uses preformatted text */
      .pre td {
        white-space: pre;
      }
      
      /* Colours for the opcodes legends */
      
      .ins0-binary {
        background-color: #8DA9E2;
      }
      
      .ins0-branch {
        background-color: #A9BFE9;
      }
      
      .ins0-float {
        background-color: #CC7C2C;
      }
      
      .ins0-move {
        background-color: #7DBD9D;
      }
      
      .ins0-other {
        background-color: #9DCEB6;
      }
      
      .ins0-stack {
        background-color: #EF7F0E;
      }
      
      .ins0-status {
        background-color: #BCAC34;
      }
      
      .ins0-unary {
        background-color: #E2CB1B;
      }
      
      /* Colour for the highlighting of opcodes */
      .hover {
        background-color: #EEEEEE;
      }
      
      /* Default count of opcodes, these are really just markers for JS */
      .count-ins0-binary::before {
        content: "0";
      }
      
      .count-ins0-branch::before {
        content: "0";
      }
      
      .count-ins0-float::before {
        content: "0";
      }
      
      .count-ins0-move::before {
        content: "0";
      }
      
      .count-ins0-other::before {
        content: "0";
      }
      
      .count-ins0-stack::before {
        content: "0";
      }
      
      .count-ins0-status::before {
        content: "0";
      }
      
      .count-ins0-unary::before {
        content: "0";
      }
    </style>
    
    <script type="text/javascript">
      /*
       * Store references to the inserted css rules in a global var. Some browsers decide that JS
       * code that responds to an event that accesses stylesheet rules may cause security problems.
       * By storing the styles we need in a global var, the event code can access them directly by
       * reference, bypassing the security mechanism.
       */
      var legendStyles = {
        hover: getCSSRules(".hover")
      };
    
      function doLoad(
      ) {
        // Get the style rule names for the opcodes from the names of the .count-insX-*::before rules, where X is 0 - 7
        for (var instrSet = 0; instrSet <= 7; instrSet++) {
          var colourRegex = new RegExp("^[.]count-(ins" + instrSet + "-[^:]*)::before$");
          var colourRules = getCSSRules(
            colourRegex
          );
          
          if (colourRules) {
            var colourNames = colourRules.map(
              function(rule) {
                return colourRegex.exec(rule.selectorText)[1];
              }
            );
        
            /*
             * Create a sorted array of {cssClass: k, count: c} pairs by counting elements in the
             * opcodes table. Sort in reverse from highest count to lowest count.
             */
            var opcodeCountsToClass = colourNames.reduce(
              function(opcodeCountsToClass, value) {
                opcodeCountsToClass.push(
                  {cssClass: value, count: document.querySelectorAll('#opcodes0 .' + value).length}
                );
                
                return opcodeCountsToClass;
              },
              []
            ).sort(
              function(a, b) {
                return b.count - a.count;
              }
            );
                    
            /*
             * Set the counts of opcodes by overriding the .count-X::before rules with new ones.
             * Re-order the colours, so that the colours are applied from most to least popular rule,
             * by overriding the .X rules that match the .count-X::before rules.
             *
             * The background-color is provided as an rgb(r,g,b) expression regardless of how it was
             * declared in the actual rule text. Some versions of IE ignore a
             * background-color: rgb(r,g,b) rule, instead expecting background: rgb(r,g,b).
             *
             * The simplest technically correct general solution is to convert the rgb expression into
             * a hex string definition.
             *
             * While we're at it, convert array of counts and names to a map of names to count
             */
            var colourNamesIndex = 0;
            var rgbRegex = /[(]\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)/;
            var opcodeCounts = {};
            opcodeCountsToClass.forEach(
              function(value) {
                // Insert count content
                insertCSSRule(".count-" + value.cssClass + "::before{content: '" + value.count + "';}");
                
                /*
                 * Insert new colour definition.
                 * The colour value we want to use is the next one from the colourNames array.
                 * The class name to define the colour for is the class of the current value.
                 */
                var rgbParts = rgbRegex.exec(
                  getCSSRules("." + colourNames[colourNamesIndex++]).style.backgroundColor
                );
                
                var hexString = "#" +
                  (rgbParts[1] < 16 ? "0" : "") + (+rgbParts[1]).toString(16) +
                  (rgbParts[2] < 16 ? "0" : "") + (+rgbParts[2]).toString(16) +
                  (rgbParts[3] < 16 ? "0" : "") + (+rgbParts[3]).toString(16);
                
                legendStyles[value.cssClass] =
                  insertCSSRule(
                    "." + value.cssClass + "{background-color: " + hexString + ";}"
                  );
                
                opcodeCounts[value.cssClass] = value.count;
              }
            );
    
            // Get the legend rows as presented        
            var originalLegend = document.querySelectorAll("#legend" + instrSet + " tbody")[0];
            
            // Get the legend rows in the order we want
            var opcodeRows = Array.prototype.slice.call(
              originalLegend.children,
              0
            ).reduce(
              // Split each row into two for sorting
              function(split, row) {
                split.push(Array.prototype.slice.call(row.children, 0, 3));
                split.push(Array.prototype.slice.call(row.children, 3));
                return split;
              },
              []
            ).sort(
              /*
               * Sort in order of decreasing opcode counts, then by ascending name.
               * Since the table is split into two columns, one row will have a blank entry if there is an odd number of
               * elements. The blank row will not have an entry in opcodeCounts, and opcodeCounts[...] will be undefined.
               * In such cases, convert undefined to 0.
               */
              function(a, b) {
                var compare = ((b[2] && opcodeCounts[b[2].className]) || 0) - ((a[2] && opcodeCounts[a[2].className]) || 0);
                return compare !== 0 ? compare : a[0].textContent.localeCompare(b[0].textContent);
              }
            ).reduce(
              // Join pairs of rows together
              function(join, row, index, sorted) {
                if (index < sorted.length / 2) {
                  join.push(row.concat(sorted[index + sorted.length / 2]));
                }
                return join;
              },
              []
            ).forEach(
              function(oldRow, index) {
                if (index === 0) {
                  while (originalLegend.hasChildNodes()) {
                    originalLegend.removeChild(originalLegend.lastChild);
                  }
                }
              
                var newRow = document.createElement("tr");
                
                oldRow.forEach(
                  function(col) {
                    newRow.appendChild(col);
                  }
                );
                
                originalLegend.appendChild(newRow);
              }
            );
            
            // Set up events for the legend
            var dom = document.querySelectorAll("#legend" + instrSet + " tbody td[class]");
            for (var i in dom) {
              dom[i].onmouseenter = doEnterExitLegend;
              dom[i].onmouseout   = doEnterExitLegend;
            }
          }
        }
      };
      
      var insertCSSRule = (function() {
        var lastStyleSheet = document.styleSheets[document.styleSheets.length - 1];
      
        return function(rule) {
          return lastStyleSheet.cssRules[
            lastStyleSheet.insertRule(
              rule,
              lastStyleSheet.cssRules.length
            )
          ];
        };
      })(); 
            
      function getCSSRules(ruleTest, deleteFlag) {
        var isRegex = ruleTest instanceof RegExp;
        if (! isRegex) {
          ruleTest = ruleTest.toLowerCase();
        }
        var result = false;
        
        if (document.styleSheets) {
          OUTER:
          for (var i = 0; i < document.styleSheets.length; i++) {
            var styleSheet = document.styleSheets[i];
            var cssRules = styleSheet.cssRules ? styleSheet.cssRules : styleSheet.rules;
            
            for (var j in cssRules) {
              var cssRule = cssRules[j];
              
              // Not all CSS Rule objects have a selectorText property
              if (
                cssRule &&
                cssRule.selectorText &&
                (
                  (isRegex && ruleTest.test(cssRule.selectorText.toLowerCase())) ||
                  ((! isRegex) && (cssRule.selectorText.toLowerCase() === ruleTest))
                )
              ) {
                if (deleteFlag === 'delete') {
                  if (styleSheet.deleteRule) {
                    styleSheet.deleteRule(j);
                  } else {
                    styleSheet.removeRule(j);
                  }
                  
                  result = true;
                  break OUTER;
                } else if (isRegex) {
                  if (result === false) {
                    result = [cssRule];
                  } else {
                    result.push(cssRule);
                  }
                } else {
                  result = cssRule;
                  break OUTER;
                }
              }
            }
          }
        }
        
        return result;
      };
      
      function doEnterExitLegend(
        e
      ) {
        var evt = e || window.event;
        var source = evt.target || evt.srcElement;
        
        var srcRule = legendStyles[source.className];
        var dstRule = legendStyles.hover;
        
        var tmp = srcRule.style.backgroundColor;
        srcRule.style.backgroundColor = dstRule.style.backgroundColor;
        dstRule.style.backgroundColor = tmp;
      };
    </script>
  </head>
  <body onload="doLoad();">
    <h1>Instruction Set</h1>
    
    <h2>Example code</h2>
    <table>
      <thead>
        <tr>
          <th>Comment</th>
          <th>Code</th>
        </tr>
      </thead>
      <tbody class="pre">
        <tr>
<td>Read/write single 8 bit value</td>
<td>  LD    DP0,  0x010000 ; Initialize DP0
  SOS8                 ; Read/write 8 bits 
  SDAM*                ; *PTR addressing mode
  LD    PTR0, 0x0200   ; Load pointer with address DP0 + 0x0200 = 0x010200
  RD    R0,   *PTR     ; Read derefd ptr into R
  INC   R0             ; R0 = R0 + 1
  WD    *PTR, R0       ; Write R0 into derefd pointer
</td>
        </tr>
        <tr>
<td>Sum one dimensional array of 10 16-bit ints</td>
<td>  LD    DP0,  0x010000    ; Initialize DP0
  SOS16                   ; Set operand size = 16 bits
  SDAM*[]                 ; *(PTR + IX) addressing mode
  LD    PTR0, 0x0200      ; Load pointer with address DP + 0x0200 = 0x010200
  LD    IX0, (10 - 1) * 2 ; IX0 = index of first byte of last 16-bit value
  ZRO   R0                ; R0 = 0
SUM:
  LD    R0c, *PTR         ; R0c = *(PTR0 + IX0)
  ADD   R0,R0c            ; R0 = R0 + R0c
  DEC   IX0               ; IX0 = IX0 - operand size
  BPL   SUM               ; LOOP again if IX0 >= 0
                          ; R0 contains sum
</td>
        </tr>
        <tr>
          <td>Sum two dimensional array of 5 rows of 10 32-bit ints</td>
          <td>  LD    DP0,  0x010000             ; Initialize DP0
  SOS32                         ; Read/write 32 bits
  SDAM*([])                     ; *(PTR + IX0 + OFS0) addressing mode
  LD    PTR0, 0x0200            ; Load pointer with address DP0 + 0x0200 = 0x010200
  LD    IX0, (5 - 1) * (10 * 4) ; first byte of last row  
  ZRO   R0                      ; R0 = 0
ROW:
  LD    OFS0, 9 * 4             ; first byte of last int in current row
SUM:
  LD    R0c, *PTR               ; R0c = *(PTR0 + IX0 + OFS0)
  ADD   R0, R0c                 ; R0 = R0 + R0c
  DEC   OFS                     ; OFS0 = OFS0 - operand size
  BPL   SUM                     ; continue summing row if OFS0 >= 0
  SUB   IX0, 10 * 4             ; IX0 = IX0 - length of row
  BPL   ROW                     ; sum next row if IX0 >= 0
                                ; R0 contains sum 
</td>
        </tr>
        <tr>
          <td>Access an 8-bit field of an object</td>
          <td>  LD    DP0,  0x010000 ; Initialize DP0 
  SOS8                 ; Read/write 8 bits
  SDAM*()              ; *(PTR + OFS) addresssing mode
  LD    PTR0, 0x0200   ; Load pointer with address DP0 + 0x0200 = 0x010200
  LD    OFS0, 0x10     ; Field offset
  RD    R0,    *PTR    ; R0 = *(DP0 + 0x0200 + 0x10)
  INC   R0             ; R = R + 1
  WD    *PTR, R0       ; *(DP0 + 0x0200 + 0x10) = R
          </td>
        </tr>
        <tr>
          <td>Execute a method for an object
- Code pointer at 0x020000
- Data pointer at 0x010000
- Object at PTR0 = DP0 + 0x0200 = 0x010200
- First field at 0x010200 points to
  class def at CP + 0x0300 = 0x020300
- Class def method pointer at offset 0x10
  (0x020310) points to CP + 1200 = 0x021200
          </td>
          <td>  LD    DP0,  0x010000 ; Initialize DP0
  SOS32                ; Read/write 32 bits
  SCAM*(*)             ; *(CP + *(DP + PTR) + OFS)
  LD    PTR0, 0x0200   ; Load pointer with address DP + 0x0200 
  LD    OFS0, 0x10     ; Field offset of method
  RD    R0,   *PTR     ; R0 = *(CP + *(DP + 0x0200) + 0x10) = *(CP + 0x0300 + 0x10) = *020310 = 0x1200
  JSR   R0             ; Call method at CP + 0x1200 = 0x021200

0x021200:
                   ; Assume PTR0 is this object
  PSH   ST         ; Push Status
  PSH   R0         ; Push R0
  PSH   OFS0       ; Push OFS0
  SDAM*()          ; *(PTR + OFS)
  SOS8             ; Read/write 8 bits
  LD    OFS0, 0x30 ; Field offset of this object
  RD    R0,   *PTR ; R0 = *(DP + 0x0200 + 0x30) = *(0x010230)
  INC   R0         ; R0 = R0 + 1
  WD    *PTR, R0   ; Write R0 to 0x010230
  PUL OFS0         ; Pull OFS
  PUL R0           ; Pull R0
  PUL ST           ; Pull Status
  RTS              ; Return to caller 
          </td>
        </tr>
      </tbody>
    </table> 
    
    <h2>Registers</h2>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Purpose</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>R0, R0c, R1, R1c</td>
          <td>
            64 bit (un)signed general purpose registers that work in two pairs: (R0, R0c) and (R2, R1c).<br>
            Instructions that require two of these registers will work with a pair,<br>
            where one register is referred to as the complement:<br>
            R0 complement = R0c<br>
            R1 complement = R1c<br>
            When a literal or memory operand is loaded into a register, and the current operand size<br>
            is less than 64 bits, the highest bit of the operand is copied into the upper bits to extend the sign.
          </td>
        </tr>
        <tr>
          <td>DP0, DP1</td>
          <td>32 bit unsigned data pointers. DP0 is for (R0, R0c), DP1 is for (R1, R1c).</td>
        </tr>
        <tr>
          <td>CP</td>
          <td>32 bit unsigned code pointer</td>
        </tr>
        <tr>
          <td>PTR0, PTR1</td>
          <td>32 bit unsigned pointer registers: PTR0 is for (R0, R1), PTR1 is for (R2, R3)</td>
        </tr>
          <td>IX0, IX1</td>
          <td>16 bit unsigned index registers: IX0 is for (R0, R1), IX1 is for (R2, R3)</td>
        </tr>
        </tr>
          <td>OFS0, OFS1</td>
          <td>16 bit unsigned index registers: OFS0 is for (R0, R0c), OFS1 is for (R1, R1c)</td>
        </tr>
        <tr>
          <td>PC</td>
          <td>32 bit unsigned program counter</td>
        </tr>
        <tr>
          <td>ST</td>
          <td>32 bit unsigned status register, consists of CVZNAAAA OOMMI--- SSSSSSSS UUUUUUUU:<br>
              Carry, oVerflow, Zero, Negative, Address mode, Interrupt Disable<br>
              general Register, counTer register, Operand size, Math mode, unused<br>
              There are 8 bits reserved for system use, and 8 bits reserved for user use.
          </td>
        </tr>
        <tr>
          <td>SB</td>
          <td>
            32 bit unsigned stack base register<br>
            Default location is FFFF0000 (highest 64k)
          </td>
        </tr>
        <tr>
          <td>SP</td>
          <td>
            16 bit unsigned stack pointer register<br>
            Default value is FFFF (counts backwards as items are pushed)
          </td>
        </tr>
      </tbody>
    </table>

    <h2>ST values</h2>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>C</td>
          <td>Carry</td>
        </tr>
        <tr>
          <td>V</td>
          <td>Overflow</td>
        </tr>
        <tr>
          <td>Z</td>
          <td>Zero</td>
        </tr>
        <tr>
          <td>N</td>
          <td>Negative</td>
        </tr>
        <tr>
          <td>AAAA</td>
          <td>
            Selected DP Address Mode:<br>
            PTR = 100, OFS = 25, IX = 400, DP + 100 = 200, DP + 125 = 300, DP + 500 = 700, DP + 525 = 800<br>
            0000 = *PTR = *(DP + PTR) = *(DP + 100)<br>
            0001 = *(PTR) = *(DP + PTR + OFS) = *(DP + 125)<br>
            0010 = *[PTR] = *(DP + PTR + IX) = *(DP + 500)<br>
            0011 = *([PTR]) = *(DP + PTR + OFS + IX) = *(DP + 525)<br>
            0100 = **PTR = *(DP + *(DP + PTR)) = *(DP + *(DP + 100)) = *(DP + 200)<br>
            0101 = **(PTR): *(DP + *(DP + PTR + OFS)) = *(DP + *(DP + 100 + 25)) = *(DP + 300)<br>
            0110 = **[PTR]: *(DP + *(DP + PTR + IX)) = *(DP + *(DP + 100 + 400)) = *(DP + 700)<br>
            0111 = **([PTR]): *(DP + *(DP + PTR + OFS + IX)) = *(DP + *(DP + 100 + 25 + 400)) = *(DP + 800)<br>
            Selected CP Address Mode:<br>
            PTR = 100, OFS = 25, IX = 400, DP + 100 = 200<br>
            1000 = *PTR = *(CP + PTR) = *(CP + 100)<br>
            1001 = *(PTR) = *(CP + PTR + OFS) = *(CP + 125)<br>
            1010 = *[PTR] = *(CP + PTR + IX) = *(CP + 500)<br>
            1011 = *([PTR]) = *(CP + PTR + OFS + IX) = *(CP + 525)<br>
            1100 = **PTR = *(CP + *(DP + PTR)) = *(CP + *(DP + 100)) = *(CP + 200)<br>
            1101 = *(*PTR): *(CP + *(DP + PTR) + OFS) = *(CP + *(DP + 100) + 25) = *(CP + 225)<br>
            1110 = *[*PTR]: *(CP + *(DP + PTR) + IX) = *(CP + *(DP + 100) + 400) = *(CP + 600)<br>
            1111 = *([*PTR]): *(CP + *(DP + PTR) + OFS + IX) = *(CP + *(DP + 100) + 25 + 400) = *(CP + 625)
          </td>
        </tr>
        <tr>
          <td>OO</td>
          <td>
            Selected Operand Size<br>
            00: 8 bits<br>
            01: 16 bits<br>
            10: 32 bits<br>
            11: 64 bits
          </td>
        </tr>
        <tr>
          <td>MM</td>
          <td>
            Selected Math Mode<br>
            00 = Integer<br>
            01 = Fractional<br>
            10 = Fixed Point<br>
            11 = Floating Point<br>
            <br>
            The math mode only affects ADC, SBB, MUL, DIV, and CMP.<br>
            <br>
            Integer Mode:<br>
            Carry and Overflow are (un)signed carry and overflow.<br>
            For DIV, the quotient and remainder are stored in the selected register and complement.<br>
            For MUL, the result is twice as many bits.<br>
            For 64-bit MUL, the 128-bit product is split across (R0, R1) or (R2, R3), where R0 or R2 is highest 64 bits.<br>
            Highest bit is sign bit if using signed math.<br>
            <br>
            Fractional Mode:<br>
            A register is split into numerator (upper half) and denominator (lower half).<br>
            Numerator highest bit is sign bit if using signed math.<br> 
            Denominator is always unsigned.<br>
            If operand size is 8 bits, a 16 bit value is used.<br>
            Otherwise operates like Integer Mode.<br>
            <br>
            Fixed Point Mode:<br>
            Scaling factor and min/max range limited to decimal values:<br>
            16 bits: scaling factor = 10^-2, range = +/-99.99.<br>
            32 bits: scaling factor = 10^-4, range = +/-99,999.9999.<br>
            64 bits: scaling factor = 10^-8, range = +/-99,999,999,999.99999999.<br>
            If operand size is 8 bits, a 16 bit value is used.<br>
            Otherwise operates like Integer Mode.<br>
            <br>
            Floating Point Mode:<br>
            Carry = NaN.<br>
            Overflow = Divide By Zero.<br>
            ZN have usual meaning.<br>
            No unsigned math.<br>
            Implemented as IEEE 754 Half Precision (16 bits), Single Precision (32 bits), or Double Precision (64 bits).<br>
            If operand size is 8 bits, a 16 bit value is used.
          </td>
        </tr>
        <tr>
          <td>I</td>
          <td>Interrupt Disable</td>
        </tr>
      </tbody>
    </table>
    
    <h2>Instructions</h2>
    <ul>
      <li>R = Selected general purpose register</li>
      <li>Rc = Complement of selected general purpose register</li>
      <li>*PTR = Access memory of pointer register in current addressing mode</li>
      <li>OFS = Offset register</li>
      <li>IX = Index register</li>
      <li>Op1,Op2 = Operands</li>
      <li>U,S,O = (U)n(S)igned (O)perand of current size</li>
      <li>U8,U16,U32,U64,S8,S16,S32,S64 = (U)n(S)signed operand of specific size</li>
      <li>H = Highest bit, depends on operand size (bit 7, 15, 31, or 63)</li>
      <li>L = Lowest bit (bit 0)</li>
      <li>An apostrophe indicates the value after the instruction has executed</li>
    </ul>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Description</th>
          <th>Page</th>
          <th>Modes</th>
          <th>Status flags</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td colspan="4">Binary (<span class="count-ins0-binary"></span> opcodes)</td>
        </tr>
        <tr>
          <td>ADC</td>
          <td>Add with carry</td>
          <td>0</td>
          <td>
            ADC R, Rc<br>
            Op1 = Op1 + Op2 + C<br>
            C = 1 if (H(Op1) = 1 or H(Op2) = 1) and (H(Op1 + Op2 + C) = 0)<br>
            V = 1 if (H(OP1) = H(Op2)) and (H(Op1) != H(Op1 + Op2 + C))
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>ADD</td>
          <td>Add</td>
          <td>0</td>
          <td>
            ADD R, Rc<br>
            ADD OFS, U16<br>
            ADD IX, U16<br>
            Op1 = Op1 + Op2<br>
            C = 1 if (H(Op1) = 1 or H(Op2) = 1) and (H(Op1 + Op2) = 0)<br>
            V = 1 if (H(Op1) = H(Op2)) and (H(Op1) != H(Op1 + Op2)) (R, Rc only)
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>AND</td>
          <td>Bitwise</td>
          <td>0</td>
          <td>
            AND R, Rc<br>
            Op1 = Op1 ∧ Op2
          </td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td>CMP</td>
          <td>Compare</td>
          <td>0</td>
          <td>
            CMP R, Rc<br>
            CMP OFS, U16<br>
            CMP IX, U16<br>
            C = 1 if Op1 &gt;= Op2 unsigned<br>
            V = 1 if Op1 &gt;= Op2 signed (R, Rc only)<br>
            Z = 1 if Op1 = Op2
          </td>
          <td>CVZ----- --------</td>
        </tr>
        <tr>
          <td>DIVS</td>
          <td>Signed Division</td>
          <td>0</td>
          <td>
            DIVS R, Rc<br>
            Op1' = Op1 / Op2<br>
            In integer mode:<br>
            Op2' = Op1 mod Op2<br>
            N is sign of quotient and V is sign of remainder<br>
            If denominator is zero execute *FFFFFFFC interrupt with R0 = 3 (division by zero)<br>
            In floating point mode:<br>
            C and V are set<br>
            If denominator is zero, result is +/- infinity
          </td>
          <td>-VZN---- --------</td>
        </tr>
        <tr>
          <td>DIVU</td>
          <td>Unsigned Division</td>
          <td>0</td>
          <td>
            DIVU R, Rc<br>
            Op1' = Op1 / Op2<br>
            In integer mode:<br>
            Op2' = Op1 mod Op2<br>
            N is sign of quotient and V is sign of remainder<br>
            If denominator is zero execute *FFFFFFFC interrupt with R0 = 3 (division by zero)<br>
            In floating point mode:<br>
            Division is still signed<br>
            C and V are set<br>
            If denominator is zero, result is +/- infinity
          </td>
          <td>
            -VZN---- --------<br>
            C is set in floating point mode
          </td>
        </tr>
        <tr>
          <td>MULS</td>
          <td>Signed Multiply</td>
          <td>0</td>
          <td>
          	MULS R, Rc<br>
          	In integer mode:<br>
            When OO = 00, 01, or 10:<br>
            Op1 = Op1 * Op2<br>
            When OO = 11:<br>
            Op1, OP2 = Op1 * Op2<br>
            Op1 is lower 64 bits, Op2 is upper 64 bits<br>
            In floating point mode:<br>
            Op1 = Op1 * Op2
          </td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td>MULU</td>
          <td>Unsigned Multiply</td>
          <td>0</td>
          <td>
            MULU R, Rc<br>
          	In integer mode:<br>
            When OO = 00, 01, or 10:<br>
            Op1 = Op1 * OP2<br>
            When OO = 11:<br>
            Op1, Op2 = Op1 * Op2<br>
            Op1 is lower 64 bits, Op2 is upper 64 bits<br>
            In floating point mode:<br>
            Multiplication is still signed<br>
            Op1 = Op1 * Op2
          </td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td>OR</td>
          <td>Bitwise OR</td>
          <td>0</td>
          <td>
            OR R, Rc<br>
            Op1 = Op1 ∨ Op2
          </td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td>SHA</td>
          <td>Shift right arithmetic</td>
          <td>0</td>
          <td>
            SHA R, Rc<br>
            Op1 = Op1 &gt;&gt; Op2<br>
            Highest Op2 bits of Op1' = H(Op1), causing the sign of Op1 to remain the same<br>
            C = 1 if any of the lower Op2 bits of Op1 are set
          </td>
          <td>C-ZN---- --------</td>
        </tr>
        <tr>
          <td>SHL</td>
          <td>Shift left</td>
          <td>0</td>
          <td>
            SHL R, Rc<br>
            Op1 = Op1 &lt;&lt; Op2<br>
            C = 1 if any of the upper Op2 bits of Op1 are set
          </td>
          <td>C-ZN---- --------</td>
        </tr>
        <tr>
          <td>SHR</td>
          <td>Shift right</td>
          <td>0</td>
          <td>
            SHR R, Rc<br>
            Op1 = Op1 &gt;&gt; OP2<br>
            C = 1 if any of the lower Op2 bits of Op1 are set
          </td>
          <td>C-ZN---- --------</td>
        </tr>
        <tr>
          <td>SBB</td>
          <td>Subtract with borrow</td>
          <td>0</td>
          <td>
            SBB R, Rc<br>
            Op1 = Op1 - Op2 - C<br>
            C = 1 if Op1' > Op1 unsigned<br>
            V = 1 if (H(Op1') != H(Op1)) and (H(Op2) = H(Op1'))<br>
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>SUB</td>
          <td>Subtract</td>
          <td>0</td>
          <td>
            R = R - Rc<br>
            OFS = OFS - U16<br>
            IX = IX - U16<br>
            Op1 = Op1 - Op2<br>
            C = 1 if Op1' > Op1 unsigned<br>
            V = 1 if (H(Op1') != H(Op1)) and (H(Op1) = H(Op1')) (R, Rc only)<br>
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>XOR</td>
          <td>Bitwise XOR</td>
          <td>0</td>
          <td>
            XOR R, Rc<br>
            Op1 = Op1 ⊻ Op2<br>
          </td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td colspan="4">Branch and Jump (<span class="count-ins0-branch"></span> opcodes)</td>
        </tr>
        <tr>
          <td>BCC (BLTU, BNANC)</td>
          <td>Branch on carry clear (R &lt; Rc unsigned, FP result is not NaN)</td>
          <td>0</td>
          <td>
            BCC S8<br>
            PC = PC + Op1 if C = 0
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BCS (BGEU, BNANS)</td>
          <td>Branch on carry set (R &gt;= Rc unsigned, FP result is NaN)</td>
          <td>0</td>
          <td>
            BCS S8<br>
            PC = PC + Op1 if C = 1
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BVC (BLTS, BDZC)</td>
          <td>Branch on overflow clear (R &lt; Rc signed, Divide by zero clear)</td>
          <td>0</td>
          <td>
            BVC S8<br>
            PC = PC + Op1 if V = 0
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BVS (BGES, BDZS)</td>
          <td>Branch on overflow set (R &gt;= Rc signed, Divide by zero set)</td>
          <td>0</td>
          <td>
            BVS S8<br>
            PC = PC + Op1 if V = 1
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BEQ</td>
          <td>Branch on equal to zero (R = Rc)</td>
          <td>0</td>
          <td>
            BEQ S8<br>
            PC = PC + Op1 if Z = 1
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BNE</td>
          <td>Branch on not equal to zero (R != Rc)</td>
          <td>0</td>
          <td>
            BNE S8<br>
            PC = PC + Op1 if Z = 0
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BMI</td>
          <td>Branch on negative</td>
          <td>0</td>
          <td>
            BMI S8<br>
            PC = PC + Op1 if N = 1
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BPL</td>
          <td>Branch on positive (or zero)</td>
          <td>0</td>
          <td>
            BPL S8<br>
            PC = PC + Op1 if N = 0
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>JMA</td>
          <td>Jump to an absolute unsigned address</td>
          <td>0</td>
          <td>
            JMA R0<br>
            JMA U32<br>
            PC = (lowest 32 bits of Op1)
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>JMP</td>
          <td>Jump to relative signed address</td>
          <td>0</td>
          <td>
            JMP R0<br>
            JMP S16<br>
            PC = PC + (lowest 16 bits of Op1)
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>JSA</td>
          <td>Jump to subroutine at an absolute unsigned address</td>
          <td>0</td>
          <td>
            JSA R0<br>
            JSA U32<br>
            Push PC; PC = (lowest 32 bits of Op1)
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>JSR</td>
          <td>Jump to subroutine at a relative signed address</td>
          <td>0</td>
          <td>
            JSR R0<br>
            JSR S16<br>
            Push PC; PC = PC + (lowest 16 bits of R)
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>RTS</td>
          <td>Return from subroutine</td>
          <td>0</td>
          <td>
            RTS<br>
            RTS U8<br>
            Pull PC<br>
            SP = SP + U8; Pull PC<br>
            A hardware error occurs if the stack underflows
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>RTI</td>
          <td>Return from interrupt</td>
          <td>0</td>
          <td>
            RTI<br>
            Pull R0;<br>
            Pull R0c;<br>
            Pull R1;<br>
            Pull R1c;<br>
            Pull DP0;<br>
            Pull PTR0;<br>
            Pull IX0;<br>
            Pull OFS0;<br>
            Pull DP1;<br>
            Pull PTR1;<br>
            Pull IX1;<br>
            Pull OFS1;<br>
            Pull ST;<br>
            Pull CP;<br>
            Pull PC<br>
            A hardware error occurs if the stack underflows<br>
            Pulling CP and PC do not affect status flags
          </td>
          <td>CVZNAAAI OOMM----</td>
        </tr>
        <tr>
          <td colspan="4">Floating Point (<span class="count-ins0-float"></span> opcodes)</td>
        </tr>
        <tr>
          <td>F2SF</td>
          <td>Signed integer to floating point</td>
          <td>0</td>
          <td>
            F2SF R<br>
            F2SF Rc<br>
            Op1(floating point) = Op1(signed int)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FABS</td>
          <td>Absolute value</td>
          <td>0</td>
          <td>
            FABS R<br>
            FABS Rc<br>
            Op1 = ABS(Op1)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FACS</td>
          <td>Arc cosine</td>
          <td>0</td>
          <td>
            FACS R, Rc<br>
            Op1 = ARCCOS(Op2)
          </td>
          <td>--Z---- --------</td>
        </tr>
        <tr>
          <td>FASN</td>
          <td>Arc sine</td>
          <td>0</td>
          <td>
            FASN R, Rc<br>
            Op1 = ARCSIN(Op2)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FATN</td>
          <td>Arc tangent</td>
          <td>0</td>
          <td>
            FATN R, Rc<br>
            Op1 = ARCTAN(Op2)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FCEL</td>
          <td>Ceiling</td>
          <td>0</td>
          <td>
            FCEL R<br>
            FCEL Rc<br>
            Op1 = CEIL(Op1)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FCOS</td>
          <td>Cosine</td>
          <td>0</td>
          <td>
            FCOS R, Rc<br>
            Op1 = COS(Op2)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FF2S</td>
          <td>Floating point to signed integer</td>
          <td>0</td>
          <td>
            FF2S R<br>
            FF2S Rc<br>
            Op1(signed int) = Op1(floating point)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FF2U</td>
          <td>Floating point to unsigned integer</td>
          <td>0</td>
          <td>
            FF2U R<br>
            FF2U Rc<br>
            Op1(unsigned int) = Op1(floating point)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FFLR</td>
          <td>Floor</td>
          <td>0</td>
          <td>
            FFLR R<br>
            FFLR Rc<br>
            Op1 = FLOOR(Op1)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FLOG</td>
          <td>Logarithm base 10</td>
          <td>0</td>
          <td>
            FLOG R, Rc<br>
            Op1 = LOG10(Op2)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FNLG</td>
          <td>Logarithm base E</td>
          <td>0</td>
          <td>
            FNLG R, Rc<br>
            Op1 = LOGE(Op2)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FPOW</td>
          <td>Power</td>
          <td>0</td>
          <td>
            FPOW R,Rc<br>
            Op1 = Op1 ^ Op2
          </td>
          <td>-VZN--- --------</td>
        </tr>
        <tr>
          <td>FSIN</td>
          <td>Sine</td>
          <td>0</td>
          <td>
            FSIN R, Rc<br>
            Op1 = SIN(Op2)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FSQR</td>
          <td>Square root</td>
          <td>0</td>
          <td>
            FSQR R, Rc<br>
            Op1 = √Op2
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FTAN</td>
          <td>Tangent</td>
          <td>0</td>
          <td>
            FTAN R<br>
            FTAN Rc<br>
            Op1 = TAN(Op2)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FU2F</td>
          <td>Unsigned integer to floating point</td>
          <td>0</td>
          <td>
            FU2F R<br>
            FU2F Rc<br>
            Op1(floating point) = Op1(unsigned int)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td colspan="4">Move (<span class="count-ins0-move"></span> opcodes)</td>
        </tr>
        <tr>
          <td>MOV</td>
          <td>Move data</td>
          <td>0</td>
          <td>
            MOV CP, U32<br>
            MOV SB, U32<br>
            MOV SP, U16<br>
            
            MOV R0, O<br>
            MOV R0c, O<br>
            MOV R1, O<br>
            MOV R1c, O<br>
            MOV DP0, U32<br>
            MOV PTR0, U32<br>
            MOV OFS0, U16<br>
            MOV IX0, U16<br>
            MOV DP1, U32<br>
            MOV PTR1, U32<br>
            MOV OFS1, U16<br>
            MOV IX1, U16<br>
            
            MOV R0, CP<br>
            MOV R0, ST<br>
            MOV R0, SB<br>
            MOV R0, SP<br>
            MOV CP, R0<br>
            MOV ST, R0<br>
            MOV SB, R0<br>
            MOV SP, R0<br>
            
            MOV R0, R0c<br>
            MOV R0, R1<br>
            MOV R0, R1c<br>
            MOV R0c, R0<br>
            MOV R0c, R1<br>
            MOV R0c, R1c<br>            
            MOV R1, R0<br>
            MOV R1, R0c<br>
            MOV R1, R1c<br>
            MOV R1c, R0<br>
            MOV R1c, R0c<br>
            MOV R1c, R1<br>
            
            MOV R0, DP0<br>
            MOV R0, PTR0<br>
            MOV R0, *PTR0<br>
            MOV R0, OFS0<br>
            MOV R0, IX0<br>
            MOV DP0, R0<br>
            MOV PTR0, R0<br>
            MOV *PTR0, R0<br>
            MOV OFS0, R0<br>
            MOV IX0, R0<br>
            
            MOV R1, DP1<br>
            MOV R1, PTR1<br>
            MOV R1, *PTR1<br>
            MOV R1, OFS1<br>
            MOV R1, IX1<br>
            MOV DP1, R1<br>
            MOV PTR1, R1<br>
            MOV *PTR1, R1<br>
            MOV OFS1, R1<br>
            MOV IX1, R1<br>
            
            MOV R0, M
            MOV R0, *SP[U8]<br>
            MOV R0c, *SP[U8]<br>
            MOV R1, *SP[U8]<br>
            MOV R1c, *SP[U8]<br>
            MOV M, R0
            MOV *SP[U8], R0<br>
            MOV *SP[U8], R0c<br>
            MOV *SP[U8], R1<br>
            MOV *SP[U8], R1c<br>
          </td>
          <td>
            --ZN---- --------<br>
            MOV R0, CP and MOV R0, ST do not affect status flags
          </td>
        </tr>
        <tr>
          <td>SWP</td>
          <td>Swap data</td>
          <td>0</td>
          <td>
            SWP R0, R0c<br>
            SWP R0, R1<br>
            SWP R0, R1c<br>
            SWP R0c, R1<br>
            SWP R0c, R1c<br>
            SWP R1, R1c<br>
            
            SWP R0, PTR0<br>
            SWP R0, *PTR0<br>
            SWP R0, OFS0<br>
            SWP R0, IX0<br>
            SWP R1, PTR1<br>
            SWP R1, *PTR1<br>
            SWP R1, OFS1<br>
            SWP R1, IX1<br>
            
            SWP R0, M<br>
            SWP R1, M
          </td>
          <td>
            --ZN---- --------<br>
          </td>
        </tr>
        <tr>
          <td colspan="4">Other (<span class="count-ins0-other"></span> opcodes)</td>
        </tr>
        <tr>
          <td>NOP</td>
          <td>No operation</td>
          <td>0</td>
          <td>Waste a CPU cycle</td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>EXT</td>
          <td>Extended Instruction</td>
          <td>0</td>
          <td>Read next byte and execute as a page 1 instruction</td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td colspan="4">Stack (<span class="count-ins0-stack"></span> opcodes)</td>
        </tr>
        <tr>
          <td>PSH</td>
          <td>Push on the stack</td>
          <td>0</td>
          <td>
            If there is not enough room left on the stack, execute *FFFFFFFC interrupt with R0 = 1 (stack overflow)<br>
            *SP = register<br>
            SP = SP - register size<br>
            <br>
            PSH CP<br>
            PSH ST<br>
            
            PSH R0<br>
            PSH R0c<br>
            PSH R1<br>
            PSH R1c<br>
            
            PSH DP0<br>
            PSH PTR0<br>
            PSH OFS0<br>
            PSH IX0<br>
            
            PSH DP1<br>
            PSH PTR1<br>
            PSH OFS1<br>
            PSH IX1<br>
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>PUL</td>
          <td>Pull off the stack</td>
          <td>0</td>
          <td>
            If there are not enough bytes in the stack, execute *FFFFFFFC interrupt with R0 = 2 (stack underflow)<br>
            SP = SP + register size<br>
            register = *SP<br>
            <br>
            PUL CP<br>
            PUL ST<br>
            
            PUL R0<br>
            PUL R0c<br>
            PUL R1<br>
            PUL R1c<br>
            
            PUL DP0<br>
            PUL PTR0<br>
            PUL OFS0<br>
            PUL IX0<br>
            
            PUL DP1<br>
            PUL PTR1<br>
            PUL OFS1<br>
            PUL IX1<br>
          </td>
          <td>
            --ZN---- --------<br>
            PUL CP does not affect ST<br>
            PUL ST affects all flags
          </td>
        </tr>
        <tr>
          <td>SSP</td>
          <td>Subtract from stack pointer</td>
          <td>0</td>
          <td>
            If there is not enough stack space execute *FFFFFFFC interrupt with R0 = 1 (stack overflow)<br>
            SP = SP - U8
          </td>
          <td>--------- --------</td>
        </tr>
        <tr>
          <td colspan="4">Status (<span class="count-ins0-status"></span> opcodes)</td>
        </tr>
        <tr>
          <td>CLC</td>
          <td>Clear carry flag (Clear NaN)</td>
          <td>0</td>
          <td>Set C = 0</td>
          <td>0------- --------</td>
        </tr>
        <tr>
          <td>SEC</td>
          <td>Set carry flag (Set NaN)</td>
          <td>0</td>
          <td>Set C = 1</td>
          <td>1------- --------</td>
        </tr>
        <tr>
          <td>SDAM*</td>
          <td>Select data address mode 0: *(DP + PTR)</td>
          <td>0</td>
          <td>Set AAAA = 0</td>
          <td>----0000 --------</td>
        </tr>
        <tr>
          <td>SDAM*()</td>
          <td>Select data address mode 1: *(DP + PTR + OFS)</td>
          <td>0</td>
          <td>Set AAAA = 1</td>
          <td>----0001 --------</td>
        </tr>
        <tr>
          <td>SDAM*[]</td>
          <td>Select data address mode 2: *(DP + PTR)</td>
          <td>0</td>
          <td>Set AAAA = 2</td>
          <td>----0010 --------</td>
        </tr>
        <tr>
          <td>SDAM*([])</td>
          <td>Select data address mode 3: *(DP + PTR + IX + OFS)</td>
          <td>0</td>
          <td>Set AAAA = 3</td>
          <td>----0011 --------</td>
        </tr>
        <tr>
          <td>SDAM**</td>
          <td>Select data address mode 4: *(DP + *(DP + PTR))</td>
          <td>0</td>
          <td>Set AAAA = 4</td>
          <td>----0100 --------</td>
        </tr>
        <tr>
          <td>SDAM**()</td>
          <td>Select data address mode 5: *(DP + *(DP + PTR + OFS))</td>
          <td>0</td>
          <td>Set AAAA = 5</td>
          <td>----0101 --------</td>
        </tr>
        <tr>
          <td>SDAM**[]</td>
          <td>Select data address mode 6: *(DP + (*DP + PTR + IX))</td>
          <td>0</td>
          <td>Set AAAA = 6</td>
          <td>----0110 --------</td>
        </tr>
        <tr>
          <td>SDAM**([])</td>
          <td>Select data address mode 7: *(DP + (*DP + PTR + OFS + IX))</td>
          <td>0</td>
          <td>Set AAAA = 7</td>
          <td>----0111 --------</td>
        </tr>
        <tr>
          <td>SCAM*</td>
          <td>Select code address mode 8: *(CP + PTR)</td>
          <td>0</td>
          <td>Set AAAA = 8</td>
          <td>----1000 --------</td>
        </tr>
        <tr>
          <td>SCAM*()</td>
          <td>Select code address mode 9: *(CP + PTR + OFS)</td>
          <td>0</td>
          <td>Set AAAA = 9</td>
          <td>----1001 --------</td>
        </tr>
        <tr>
          <td>SCAM*[]</td>
          <td>Select code address mode 10: *(CP + PTR + IX)</td>
          <td>0</td>
          <td>Set AAAA = 10</td>
          <td>----1010 --------</td>
        </tr>
        <tr>
          <td>SCAM*([])</td>
          <td>Select code address mode 11: *(CP + PTR + OFS + IX)</td>
          <td>0</td>
          <td>Set AAAA = 11</td>
          <td>----1011 --------</td>
        </tr>
        <tr>
          <td>SCAM**</td>
          <td>Select code address mode 12: *(CP + *(DP + PTR))</td>
          <td>0</td>
          <td>Set AAAA = 12</td>
          <td>----1100 --------</td>
        </tr>
        <tr>
          <td>SCAM*(*)</td>
          <td>Select code address mode 13: *(CP + *(DP + PTR) + OFS)</td>
          <td>0</td>
          <td>Set AAAA = 13</td>
          <td>----1101 --------</td>
        </tr>
        <tr>
          <td>SCAM*[*]</td>
          <td>Select code address mode 14: *(CP + *(DP + PTR) + IX)</td>
          <td>0</td>
          <td>Set AAAA = 14</td>
          <td>----1110 --------</td>
        </tr>
        <tr>
          <td>SCAM*([*])</td>
          <td>Select code address mode 15: *(CP + *(DP + PTR) + OFS + IX)</td>
          <td>0</td>
          <td>Set AAAA = 15</td>
          <td>----1111 --------</td>
        </tr>
        <tr>
          <td>SOS8</td>
          <td>Select operand size 0 (8 bits)</td>
          <td>0</td>
          <td>Set OO = 0</td>
          <td>-------- 00------</td>
        </tr>
        <tr>
          <td>SOS16</td>
          <td>Select operand size 1 (16 bits)</td>
          <td>0</td>
          <td>Set OO = 1</td>
          <td>-------- 01------</td>
        </tr>
        <tr>
          <td>SOS32</td>
          <td>Select operand size 2 (32 bits)</td>
          <td>0</td>
          <td>Set OO = 2</td>
          <td>-------- 10------</td>
        </tr>
        <tr>
          <td>SOS64</td>
          <td>Select operand size 3 (64 bits)</td>
          <td>0</td>
          <td>Set OO = 3</td>
          <td>-------- 11------</td>
        </tr>
        <tr>
          <td>SMMI</td>
          <td>Select math mode 0 (integer)</td>
          <td>0</td>
          <td>Set MM = 0</td>
          <td>-------- --00----</td>
        </tr>
        <tr>
          <td>SMMR</td>
          <td>Select math mode 1 (fractional)</td>
          <td>0</td>
          <td>Set MM = 1</td>
          <td>-------- --01----</td>
        </tr>
        <tr>
          <td>SMMX</td>
          <td>Select math mode 2 (fixed point)</td>
          <td>0</td>
          <td>Set MM = 2</td>
          <td>-------- --10----</td>
        </tr>
        <tr>
          <td>SMMF</td>
          <td>Select math mode 3 (floating point)</td>
          <td>0</td>
          <td>Set MM = 3</td>
          <td>-------- --11----</td>
        </tr>
        <tr>
          <td>CLI</td>
          <td>Clear interrupt disable flag</td>
          <td>0</td>
          <td>Set I = 0</td>
          <td>-------- ----0---</td>
        </tr>
        <tr>
          <td>SEI</td>
          <td>Set interrupt disable flag</td>
          <td>0</td>
          <td>Set I = 1</td>
          <td>-------- ----1---</td>
        </tr>
        <tr>
          <td colspan="4">Unary (<span class="count-ins0-unary"></span> opcodes)</td>
        </tr>
        <tr>
          <td>DEC</td>
          <td>Decrement</td>
          <td>0</td>
          <td>
            DEC R<br>
            Op = Op - 1<br>
            C = 1 if H(Op) = 0 and (H(Op') = 1)<br>
            V = 1 if (H(Op) = 1) and (H(Op') = 0)<br>
            Z = 1 if Op' = 0<br>
            N = H(Op')
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>INC</td>
          <td>Increment</td>
          <td>0</td>
          <td>
            INC R<br>
            Op = Op + 1<br>
            C = 1 if (H(Op) = 1) and (H(Op') = 0)<br>
            V = 1 if (H(Op) = 0) and (H(Op') = 1)<br>
            Z = 1 if Op' = 0<br>
            N = H(Op')
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>NEG</td>
          <td>Negate</td>
          <td>0</td>
          <td>
            NEG R<br>
            Op = -Op<br>
            Z = 1 if Op' = 0<br>
            N = H(Op')
          </td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td>NG1</td>
          <td>Set to -1</td>
          <td>0</td>
          <td>
            NG1 R<br>
            Op = -Op<br>
            Z = 0<br>
            N = 1
          </td>
          <td>--01----- --------</td>
        </tr>
        <tr>
          <td>NOT</td>
          <td>Bitwise NOT</td>
          <td>0</td>
          <td>
            NOT R<br>
            Op = ~Op<br>
            Z = 1 if Op' = 0<br>
            N = H(Op')
          </td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td>NEXT</td>
          <td>Add operand size to register</td>
          <td>0</td>
          <td>
            NEXT OFS<br>
            NEXT IX<br>
            Op = Op + operand size (1 - 4)<br>
            CVZN are set the same as for ADD
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>ONE</td>
          <td>Set to 1</td>
          <td>0</td>
          <td>
            ONE R<br>
            ONE OFS<br>
            ONE IX<br>
            Op = 1<br>
          </td>
          <td>--00---- --------</td>
        </tr>
        <tr>
          <td>PREV</td>
          <td>Subtract operand size from register</td>
          <td>0</td>
          <td>
            PREV OFS<br>
            PREV IX<br>
            Op = Op - operand size (1 - 4)<br>
            CVZN are set the same as for SUB
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>SHA</td>
          <td>Arithmetic shift right</td>
          <td>0</td>
          <td>
            SHA R<br>
            Op = Op &gt;&gt; 1<br>
            H(Op') = H(Op)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>SHL</td>
          <td>Shift left with carry</td>
          <td>0</td>
          <td>
            SHL R<br>
            Op = Op &lt;&lt; 1<br>
            L(Op') = C<br>
            C = H(Op)
          </td>
          <td>C-ZN--- --------</td>
        </tr>
        <tr>
          <td>SHR</td>
          <td>Shift right with carry</td>
          <td>0</td>
          <td>
            SHR R<br>
            Op = Op &gt;&gt; 1<br>
            H(Op') = C<br>
            C = L(Op)
          </td>
          <td>C-ZN--- --------</td>
        </tr>
        <tr>
          <td>ZRO</td>
          <td>Set to 0</td>
          <td>0</td>
          <td>
            ZRO R<br>
            ZRO OFS<br>
            ZRO IX<br>
            Op = 0
          </td>
          <td>--10---- --------</td>
        </tr>
      </tbody>
    </table>
    
    <h2>Branches and Jumps</h2>
    <p>
      All relative branches and jumps are relative to the address of the first byte of the next instruction.
      Branches use 8-bit operands, while jumps use 16-bit operands.
      Relative to the first byte of the branch itself, the 8-bit operand allows a jump in the range of [-126, 129],
      while a 16-bit operand allows a jump in the range of [-32765, 32770].
    </p>
    <p>
      JMA/JSA Allow jumps with an absolute 32-bit usigned address to any code in the system.
    </p>
    
    <h2>Interrupts</h2>
    <ul>
      <li>Interrupts can only occur by hardware, there is no instruction to invoke an interrupt.</li>
      <li>Interrupts can only occur when the Interrupt Disabled flag is clear. Any routine should set this flag
        at the start of a critical section, and clear it at the end.
      </li>
      <li>Interrupts save all registers and must end with an RTI instruction to pull all registers and resume
        execution at the interrupted code.
      </li>
      <li>Interrupts need a defined memory address to contain the pointer to the interrupt routine.
        An optional interrupt begins with the pointer set to 0, a required interrupt will
        initialize the pointer to a default routine. 
      </li>
    </ul>
    
    <h2>General Information</h2>
    <ol>
      <li>The processor is little endian - the highest byte is stored first, the lowest byte last</li>
      <li>The stack is 64k in size, the default range = FFFE0000 thru FFFEFFFF</li>
      <li>OS routines should be located in FFFF0000 thru FFFFFFFB</li>
      <li>Reset/error interrupt pointer is FFFFFFFC thru FFFFFFFF</li>
      <li>Since there is no software interrupt instruction, use JSA to call an address containing a JMA instruction that
        calls the actual routine at an OS defined address. Such a jump table provides well-known addresses for users to
        call OS routines, while allowing the OS routines to be moved around as they are updated.
      </li>
    </ol>
    
    <h2>Startup information</h2>
    <ul>
      <li>A reset executes *FFFFFFFC interrupt with R0 = 0.</li>
      <li>All other registers have undefined values on reset. A reset could occur at anytime, in which case the registers will
        still hold their current values after the reset.
      </li>
      <li>This same interrupt has other values for R0 for error conditions (see Instructions)</li>
    </ul>
    
    <h2>Opcodes</h2>
    <ul>
      <li>All unused opcodes in rows 0 thru D are reserved for future use.</li>
      <li>All opcodes in rows E and F are available for implementation use.</li>
      <li>Opcodes cannot be user defined.</li>
    </ul>
    <p>Legend</p>
    <p>Note: roll mouse over the colours in the legend to highlight the instructions in the table.</p>
    <table id="legend0">
      <thead>
        <tr>
          <th>Instruction Group</th>
          <th>Opcodes</th>
          <th>Colour</th>
          <th>Instruction Group</th>
          <th>Opcodes</th>
          <th>Colour</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Binary</td>
          <td><span class="count-ins0-binary"></span></td>
          <td class="ins0-binary"></td>
          
          <td>Branch and Jump</td>
          <td><span class="count-ins0-branch"></span></td>
          <td class="ins0-branch"></td>
        </tr>
        <tr>
          <td>Floating Point</td>
          <td><span class="count-ins0-float"></span></td>
          <td class="ins0-float"></td>

          <td>Move and swap</td>
          <td><span class="count-ins0-move"></span></td>
          <td class="ins0-move"></td>
        </tr>          
          <td>Other</td>
          <td><span class="count-ins0-other"></span></td>
          <td class="ins0-other"></td>
          
          <td>Stack</td>
          <td><span class="count-ins0-stack"></span></td>
          <td class="ins0-stack"></td>
        </tr>
        <tr>           
          <td>Status</td>
          <td><span class="count-ins0-status"></span></td>
          <td class="ins0-status"></td>

          <td>Unary</td>
          <td><span class="count-ins0-unary"></span></td>
          <td class="ins0-unary"></td>
        </tr>
      </tbody>
    </table>
    
    <p>Opcodes - Page 0</p>
    <table id="opcodes0">
      <thead>
        <tr>
          <th></th>
          <th>0</th>
          <th>1</th>
          <th>2</th>
          <th>3</th>
          <th>4</th>
          <th>5</th>
          <th>6</th>
          <th>7</th>
          <th>8</th>
          <th>9</th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
          <th>D</th>
          <th>E</th>
          <th>F</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td class="ins0-binary">ADC R0,R0c</td>
          <td class="ins0-binary">ADC R1,R1c</td>
          <td class="ins0-binary">ADD R0,R0c</td>
          <td class="ins0-binary">ADD R1,R1c</td>
          <td class="ins0-binary">ADD OFS0,U16</td>
          <td class="ins0-binary">ADD OFS1,U16</td>
          <td class="ins0-binary">ADD IX0,U16</td>
          <td class="ins0-binary">ADD IX1,U16</td>
          <td class="ins0-binary">AND R0,R0c</td>
          <td class="ins0-binary">AND R1,R1c</td>
          <td class="ins0-binary">CMP R0,R0c</td>
          <td class="ins0-binary">CMP R1,R1c</td>
          <td class="ins0-binary">CMP OFS0,U16</td>
          <td class="ins0-binary">CMP OFS1,U16</td>
          <td class="ins0-binary">CMP IX0,U16</td>
          <td class="ins0-binary">CMP IX1,U16</td>
        </tr>
        <tr>
          <th>1</th>
          <td class="ins0-binary">DIVS R0,R0c</td>
          <td class="ins0-binary">DIVS R1,R1c</td>
          <td class="ins0-binary">DIVU R0,R0c</td>
          <td class="ins0-binary">DIVU R1,R1c</td>
          <td class="ins0-binary">MULS R0,R0c</td>
          <td class="ins0-binary">MULS R1,R1c</td>
          <td class="ins0-binary">MULU R0,R0c</td>
          <td class="ins0-binary">MULU R1,R1c</td>
          <td class="ins0-binary">OR R0,R0c</td>
          <td class="ins0-binary">OR R1,R1c</td>
          <td class="ins0-binary">SHA R0,R0c</td>
          <td class="ins0-binary">SHA R1,R1c</td>
          <td class="ins0-binary">SHL R0,R0c</td>
          <td class="ins0-binary">SHL R1,R1c</td>
          <td class="ins0-binary">SHR R0,R0c</td>
          <td class="ins0-binary">SHR R1,R1c</td>
        </tr>
        <tr>
          <th>2</th>
          <td class="ins0-binary">SBB R0,R0c</td>
          <td class="ins0-binary">SBB R1,R1c</td>
          <td class="ins0-binary">SUB R0,R0c</td>
          <td class="ins0-binary">SUB R1,R1c</td>
          <td class="ins0-binary">SUB OFS0,U16</td>
          <td class="ins0-binary">SUB OFS1,U16</td>
          <td class="ins0-binary">SUB IX0,U16</td>
          <td class="ins0-binary">SUB IX1,U16</td>
          <td class="ins0-binary">XOR R0,R0c</td>
          <td class="ins0-binary">XOR R1,R1c</td>
          <td class="ins0-branch">BCC</td>
          <td class="ins0-branch">BCS</td>
          <td class="ins0-branch">BVC</td>
          <td class="ins0-branch">BVS</td>
          <td class="ins0-branch">BEQ</td>
          <td class="ins0-branch">BNE</td>
        </tr>
        <tr>
          <th>3</th>
          <td class="ins0-branch">BMI</td>
          <td class="ins0-branch">BPL</td>
          <td class="ins0-branch">JMA R0</td>
          <td class="ins0-branch">JMA U32</td>
          <td class="ins0-branch">JMP R0</td>
          <td class="ins0-branch">JMP S16</td>
          <td class="ins0-branch">JSA R0</td>
          <td class="ins0-branch">JSA U32</td>
          <td class="ins0-branch">JSR R0</td>
          <td class="ins0-branch">JSR S16</td>
          <td class="ins0-branch">RTS</td>
          <td class="ins0-branch">RTS U8</td>
          <td class="ins0-branch">RTI</td>
          <td class="ins0-float">F2SF R0</td>
          <td class="ins0-float">F2SF R0c</td>
          <td class="ins0-float">F2SF R1</td>
        </tr>
        <tr>
          <th>4</th>
          <td class="ins0-float">F2SF R1c</td>
          <td class="ins0-float">FABS R0</td>          
          <td class="ins0-float">FABS R0c</td>
          <td class="ins0-float">FABS R1</td>
          <td class="ins0-float">FABS R1c</td>
          <td class="ins0-float">FACS R0,R0c</td>
          <td class="ins0-float">FACS R1,R1c</td>
          <td class="ins0-float">FASN R0,R0c</td>
          <td class="ins0-float">FASN R1,R1c</td>
          <td class="ins0-float">FATN R0,R0c</td>
          <td class="ins0-float">FATN R1,R1c</td>
          <td class="ins0-float">FCEL R0</td>
          <td class="ins0-float">FCEL R0c</td>
          <td class="ins0-float">FCEL R1</td>
          <td class="ins0-float">FCEL R1c</td>
          <td class="ins0-float">FCOS R0,R0c</td>
        </tr>          
        <tr>
          <th>5</th>
          <td class="ins0-float">FCOS R1,R1c</td>
          <td class="ins0-float">FF2S R0</td>
          <td class="ins0-float">FF2S R0c</td>
          <td class="ins0-float">FF2S R1</td>
          <td class="ins0-float">FF2S R1c</td>
          <td class="ins0-float">FF2U R0</td>
          <td class="ins0-float">FF2U R0c</td>
          <td class="ins0-float">FF2U R1</td>
          <td class="ins0-float">FF2U R1c</td>
          <td class="ins0-float">FFLR R0</td>
          <td class="ins0-float">FFLR R0c</td>
          <td class="ins0-float">FFLR R1</td>
          <td class="ins0-float">FFLR R1c</td>
          <td class="ins0-float">FLOG R0,R0c</td>
          <td class="ins0-float">FLOG R1,R1c</td>
          <td class="ins0-float">FNLG R0,R0c</td>
        </tr>
        <tr>
          <th>6</th>
          <td class="ins0-float">FNLG R1,R1c</td>
          <td class="ins0-float">FPOW R0,R0c</td>
          <td class="ins0-float">FPOW R1,R1c</td>
          <td class="ins0-float">FSIN R0,R0c</td>
          <td class="ins0-float">FSIN R1,R1c</td>
          <td class="ins0-float">FSQR R0,R0c</td>
          <td class="ins0-float">FSQR R1,R1c</td>
          <td class="ins0-float">FTAN R0,R0c</td>
          <td class="ins0-float">FTAN R1,R1c</td>
          <td class="ins0-float">FU2F R0</td>
          <td class="ins0-float">FU2F R0c</td>
          <td class="ins0-float">FU2F R1</td>
          <td class="ins0-float">FU2F R1c</td>
          <td class="ins0-move">MOV PTR0,U32</td>
          <td class="ins0-move">MOV OFS0,U16</td>
          <td class="ins0-move">MOV IX0,U16</td>
        </tr>
        <tr>
          <th>7</th>
          <td class="ins0-move">MOV PTR1,U32</td>
          <td class="ins0-move">MOV OFS1,U16</td>
          <td class="ins0-move">MOV IX1,U16</td>
          <td class="ins0-move">MOV R0,R0c</td>
          <td class="ins0-move">MOV R0,R1</td>
          <td class="ins0-move">MOV R0,R1c</td>
          <td class="ins0-move">MOV R0c,R0</td>
          <td class="ins0-move">MOV R0c,R1</td>
          <td class="ins0-move">MOV R0c,R1c</td>
          <td class="ins0-move">MOV R1,R0</td>
          <td class="ins0-move">MOV R1,R0c</td>
          <td class="ins0-move">MOV R1,R1c</td>
          <td class="ins0-move">MOV R1c,R0</td>
          <td class="ins0-move">MOV R1c,R0c</td>
          <td class="ins0-move">MOV R1c,R1</td>
          <td class="ins0-move">MOV R0,*PTR0</td>
        </tr>
        <tr>
          <th>8</th>
          <td class="ins0-move">MOV R0,OFS0</td>
          <td class="ins0-move">MOV R0,IX0</td>
          <td class="ins0-move">MOV *PTR0,R0</td>
          <td class="ins0-move">MOV OFS0,R0</td>
          <td class="ins0-move">MOV IX0,R0</td>
          <td class="ins0-move">MOV R1,*PTR1</td>
          <td class="ins0-move">MOV R1,OFS1</td>
          <td class="ins0-move">MOV R1,IX1</td>
          <td class="ins0-move">MOV *PTR1,R1</td>
          <td class="ins0-move">MOV OFS1,R1</td>
          <td class="ins0-move">MOV IX1,R1</td>
          <td class="ins0-move">MOV R0,*SP[U8]</td>
          <td class="ins0-move">MOV R0c,*SP[U8]</td>
          <td class="ins0-move">MOV R1,*SP[U8]</td>
          <td class="ins0-move">MOV R1c,*SP[U8]</td>
          <td class="ins0-move">MOV R0,M</td>
        </tr>
        <tr>
          <th>9</th>
          <td class="ins0-move">MOV *SP[U8],R0</td>
          <td class="ins0-move">MOV *SP[U8],R0c</td>
          <td class="ins0-move">MOV *SP[U8],R1</td>
          <td class="ins0-move">MOV *SP[U8],R1c</td>
          <td class="ins0-move">MOV M,R0</td>
          <td class="ins0-move">SWP R0,R0c</td>
          <td class="ins0-move">SWP R0,R1</td>
          <td class="ins0-move">SWP R0,R1c</td>
          <td class="ins0-move">SWP R0c,R1</td>
          <td class="ins0-move">SWP R0c,R1c</td>
          <td class="ins0-move">SWP R1,R1c</td>
          <td class="ins0-move">SWP R0,*PTR0</td>
          <td class="ins0-move">SWP R0,OFS0</td>
          <td class="ins0-move">SWP R0,IX0</td>
          <td class="ins0-move">SWP R1,*PTR1</td>
          <td class="ins0-move">SWP R1,OFS1</td>
        </tr>
        <tr>
          <th>A</th>
          <td class="ins0-move">SWP R1,IX1</td>
          <td class="ins0-stack">PSH CP</td>
          <td class="ins0-stack">PSH ST</td>
          <td class="ins0-stack">PSH R0</td>
          <td class="ins0-stack">PSH R0c</td>
          <td class="ins0-stack">PSH R1</td>
          <td class="ins0-stack">PSH R1c</td>
          <td class="ins0-stack">PSH DP0</td>
          <td class="ins0-stack">PSH PTR0</td>
          <td class="ins0-stack">PSH OFS0</td>
          <td class="ins0-stack">PSH IX0</td>
          <td class="ins0-stack">PSH DP1</td>
          <td class="ins0-stack">PSH PTR1</td>
          <td class="ins0-stack">PSH OFS1</td>
          <td class="ins0-stack">PSH IX1</td>
          <td class="ins0-stack">PUL CP</td>
        </tr>
        <tr>
          <th>B</th>
          <td class="ins0-stack">PUL ST</td>
          <td class="ins0-stack">PUL R0</td>
          <td class="ins0-stack">PUL R0c</td>
          <td class="ins0-stack">PUL R1</td>
          <td class="ins0-stack">PUL R1c</td>
          <td class="ins0-stack">PUL DP0</td>
          <td class="ins0-stack">PUL PTR0</td>
          <td class="ins0-stack">PUL OFS0</td>
          <td class="ins0-stack">PUL IX0</td>
          <td class="ins0-stack">PUL DP1</td>
          <td class="ins0-stack">PUL PTR1</td>
          <td class="ins0-stack">PUL OFS1</td>
          <td class="ins0-stack">PUL IX1</td>
          <td class="ins0-stack">SSP U8</td>
          <td class="ins0-status">CLC</td>
          <td class="ins0-status">SEC</td>
        </tr>
        <tr>
          <th>C</th>
          <td class="ins0-status">SDAM*</td>
          <td class="ins0-status">SDAM*()</td>
          <td class="ins0-status">SDAM*[]</td>
          <td class="ins0-status">SDAM*([])</td>
          <td class="ins0-status">SDAM**</td>
          <td class="ins0-status">SDAM**()</td>
          <td class="ins0-status">SDAM**[]</td>
          <td class="ins0-status">SDAM**([])</td>
          <td class="ins0-status">SCAM*</td>
          <td class="ins0-status">SCAM*()</td>
          <td class="ins0-status">SCAM*[]</td>
          <td class="ins0-status">SCAM*([])</td>
          <td class="ins0-status">SCAM**</td>
          <td class="ins0-status">SCAM*(*)</td>
          <td class="ins0-status">SCAM*[*]</td>
          <td class="ins0-status">SCAM*([*])</td>
        </tr>
        <tr>
          <th>D</th>
          <td class="ins0-status">SOS8</td>
          <td class="ins0-status">SOS16</td>
          <td class="ins0-status">SOS32</td>
          <td class="ins0-status">SOS64</td>
          <td class="ins0-status">SMMI</td>
          <td class="ins0-status">SMMR</td>
          <td class="ins0-status">SMMX</td>
          <td class="ins0-status">SMMF</td>
          <td class="ins0-status">CLI</td>
          <td class="ins0-status">SEI</td>
          <td class="ins0-unary">DEC R0</td>
          <td class="ins0-unary">DEC R1</td>
          <td class="ins0-unary">INC R0</td>
          <td class="ins0-unary">INC R1</td>
          <td class="ins0-unary">NEG R0</td>
          <td class="ins0-unary">NEG R1</td>
        </tr>
        <tr>
          <th>E</th>
          <td class="ins0-unary">NG1 R0</td>
          <td class="ins0-unary">NG1 R1</td>
          <td class="ins0-unary">NOT R0</td>
          <td class="ins0-unary">NOT R1</td>
          <td class="ins0-unary">NEXT OFS0</td>
          <td class="ins0-unary">NEXT OFS1</td>
          <td class="ins0-unary">NEXT IX0</td>
          <td class="ins0-unary">NEXT IX1</td>
          <td class="ins0-unary">ONE R0</td>
          <td class="ins0-unary">ONE R1</td>
          <td class="ins0-unary">ONE OFS0</td>
          <td class="ins0-unary">ONE OFS1</td>
          <td class="ins0-unary">ONE IX0</td>
          <td class="ins0-unary">ONE IX1</td>
          <td class="ins0-unary">PREV OFS0</td>
          <td class="ins0-unary">PREV OFS1</td>
        </tr>
        <tr>
          <th>F</th>
          <td class="ins0-unary">PREV IX0</td>
          <td class="ins0-unary">PREV IX1</td>
          <td class="ins0-unary">SHA R0</td>
          <td class="ins0-unary">SHA R1</td>
          <td class="ins0-unary">SHL R0</td>
          <td class="ins0-unary">SHL R1</td>
          <td class="ins0-unary">SHR R0</td>
          <td class="ins0-unary">SHR R1</td>
          <td class="ins0-unary">ZRO R0</td>
          <td class="ins0-unary">ZRO R1</td>
          <td class="ins0-unary">ZRO OFS0</td>
          <td class="ins0-unary">ZRO OFS1</td>
          <td class="ins0-unary">ZRO IX0</td>
          <td class="ins0-unary">ZRO IX1</td>
          <td class="ins0-other">NOP</td>
          <td class="ins0-other">EXT</td>
        </tr>
      </tbody>
    </table>
    
    <p>Opcodes - Page 1</p>
    <table id="opcodes1">
      <thead>
        <tr>
          <th></th>
          <th>0</th>
          <th>1</th>
          <th>2</th>
          <th>3</th>
          <th>4</th>
          <th>5</th>
          <th>6</th>
          <th>7</th>
          <th>8</th>
          <th>9</th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
          <th>D</th>
          <th>E</th>
          <th>F</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td class="ins0-binary">ADD R0,O</td>
          <td class="ins0-binary">ADD R0c,O</td>
          <td class="ins0-binary">ADD R1,O</td>
          <td class="ins0-binary">ADD R1c,O</td>
          <td class="ins0-binary">ADD R0,*PTR0</td>
          <td class="ins0-binary">ADD R0c,*PTR0</td>
          <td class="ins0-binary">ADD R1,*PTR1</td>
          <td class="ins0-binary">ADD R1c,*PTR1</td>
          <td class="ins0-binary">ADD *PTR0,R0</td>
          <td class="ins0-binary">ADD *PTR0,R0c</td>
          <td class="ins0-binary">ADD *PTR1,R1</td>
          <td class="ins0-binary">ADD *PTR1,R1c</td>
          <td class="ins0-binary">CMP R0,O</td>
          <td class="ins0-binary">CMP R0c,O</td>
          <td class="ins0-binary">CMP R1,O</td>
          <td class="ins0-binary">CMP R1c,O</td>
        </tr>
        <tr>
          <th>1</th>
          <td class="ins0-binary">SHA R0,U8</td>
          <td class="ins0-binary">SHA R0c,U8</td>
          <td class="ins0-binary">SHA R1,U8</td>
          <td class="ins0-binary">SHA R1c,U8</td>
          <td class="ins0-binary">SHL R0,U8</td>
          <td class="ins0-binary">SHL R0c,U8</td>
          <td class="ins0-binary">SHL R1,U8</td>
          <td class="ins0-binary">SHL R1c,U8</td>
          <td class="ins0-binary">SHR R0,U8</td>
          <td class="ins0-binary">SHR R0c,U8</td>
          <td class="ins0-binary">SHR R1,U8</td>
          <td class="ins0-binary">SHR R1c,U8</td>
          <td class="ins0-binary">SUB R0,O</td>
          <td class="ins0-binary">SUB R0c,O</td>
          <td class="ins0-binary">SUB R1,O</td>
          <td class="ins0-binary">SUB R1c,O</td>
        </tr>
        <tr>
          <th>2</th>
          <td class="ins0-binary">SUB R0,*PTR0</td>
          <td class="ins0-binary">SUB R0c,*PTR0</td>
          <td class="ins0-binary">SUB R1,*PTR1</td>
          <td class="ins0-binary">SUB R1c,*PTR1</td>
          <td class="ins0-binary">SUB *PTR0,R0</td>
          <td class="ins0-binary">SUB *PTR0,R0c</td>
          <td class="ins0-binary">SUB *PTR1,R1</td>
          <td class="ins0-binary">SUB *PTR1,R1c</td>
          <td class="ins0-move">MOV CP,U32</td>
          <td class="ins0-move">MOV DP0,U32</td>
          <td class="ins0-move">MOV DP1,U32</td>
          <td class="ins0-move">MOV SB,U32</td>
          <td class="ins0-move">MOV SP,U16</td>
          <td class="ins0-move">MOV CP,R0</td>
          <td class="ins0-move">MOV ST,R0</td>
          <td class="ins0-move">MOV DP0,R0</td>
        </tr>
        <tr>
          <th>3</th>
          <td class="ins0-move">MOV PTR0,R0</td>
          <td class="ins0-move">MOV DP1,R0</td>
          <td class="ins0-move">MOV PTR1,R0</td>
          <td class="ins0-move">MOV SB,R0</td>
          <td class="ins0-move">MOV SP,R0</td>
          <td class="ins0-move">MOV R0,CP</td>
          <td class="ins0-move">MOV R0,ST</td>
          <td class="ins0-move">MOV R0,DP0</td>
          <td class="ins0-move">MOV R0,PTR0</td>
          <td class="ins0-move">MOV R0,DP1</td>
          <td class="ins0-move">MOV R0,PTR1</td>
          <td class="ins0-move">MOV R0,SB</td>
          <td class="ins0-move">MOV R0,SP</td>
          <td class="ins0-move">MOV R0,O</td>
          <td class="ins0-move">MOV R0c,O</td>
          <td class="ins0-move">MOV R1,O</td>
        </tr>
        <tr>
          <th>4</th>
          <td class="ins0-move">MOV R1c,O</td>
          <td class="ins0-move">MOV R0c,*PTR0</td>
          <td class="ins0-move">MOV R1c,*PTR1</td>
          <td class="ins0-move">MOV *PTR0,R0c</td>
          <td class="ins0-move">MOV *PTR1,R1c</td>
          <td class="ins0-move">MOV R0c,M</td>
          <td class="ins0-move">MOV R1,M</td>
          <td class="ins0-move">MOV R1c,M</td>
          <td class="ins0-move">MOV M,R0c</td>
          <td class="ins0-move">MOV M,R1</td>
          <td class="ins0-move">MOV M,R1c</td>
          <td class="ins0-move">SWP R0,M</td>
          <td class="ins0-move">SWP R0c,M</td>
          <td class="ins0-move">SWP R1,M</td>
          <td class="ins0-move">SWP R1c,M</td>
          <td class="ins0-unary">DEC R0c</td>
        </tr>          
        <tr>
          <th>5</th>
          <td class="ins0-unary">DEC R1c</td>
          <td class="ins0-unary">INC R0c</td>
          <td class="ins0-unary">INC R1c</td>
          <td class="ins0-unary">NEG R0c</td>
          <td class="ins0-unary">NEG R1c</td>
          <td class="ins0-unary">NG1 R0c</td>
          <td class="ins0-unary">NG1 R1c</td>
          <td class="ins0-unary">NOT R0c</td>
          <td class="ins0-unary">NOT R1c</td>
          <td class="ins0-unary">ONE R0c</td>
          <td class="ins0-unary">ONE R1c</td>
          <td class="ins0-unary">SHA R0c</td>
          <td class="ins0-unary">SHA R1c</td>
          <td class="ins0-unary">SHL R0c</td>
          <td class="ins0-unary">SHL R1c</td>
          <td class="ins0-unary">SHR R0c</td>
        </tr>
        <tr>
          <th>6</th>
          <td class="ins0-unary">SHR R1c</td>
          <td class="ins0-unary">ZRO R0c</td>
          <td class="ins0-unary">ZRO R1c</td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
        <tr>
          <th>7</th>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
        <tr>
          <th>8</th>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
        <tr>
          <th>9</th>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
        <tr>
          <th>A</th>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
        <tr>
          <th>B</th>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
        <tr>
          <th>C</th>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
        <tr>
          <th>D</th>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
        <tr>
          <th>E</th>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
        <tr>
          <th>F</th>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
      </tbody>
    </table>
  </body>
</html>
