<!DOCTYPE html>
<!-- SPDX-License-Identifier: Apache-2.0 -->
<html>
  <head>
    <title>Instruction Set</title>
    <style type="text/css">  
      /* FF loads whatever it can first, in the order provided. List ttf first */
      @font-face {
        font-family: "Roboto Mono";
        src: url("roboto-mono.eot");
        src: url("roboto-mono.eot?#iefix") format("embedded-opentype"),
             url("roboto-mono.woff2") format("woff2"),
             url("roboto-mono.woff") format("woff"),
             url("roboto-mono.ttf") format("truetype"),
             url("roboto-mono.svg#webfont") format("svg");
      }
      
      /* Clear spacings */
      * {
        margin: 0;
        padding: 0;
        border: none;
      }
      
      /* Set some defaults */
      body {
        margin: 5px;
        font-family: "Roboto Mono", monospace;
        font-size: 9pt;
      }
      
      /* Every sibling except the first */
      * + * {
        margin-top: 10px;
      }
      
      /* Some browsers apply * + * to <br> tags, some don't */
      br {
        margin: 0;
      }
      
      h1 {
        font-size: 1.4em;
        font-weight: bold;
      }
      
      h2 {
        font-size: 1.2em;
        font-weight: bold;
      }
      
      ol > li {
        margin-left: 2em;
      }
      
      li + li, ol ul {
        margin-top: 0.25em;
      }
      
      ul > li {
        list-style: none;
        margin-left: 1em;
      }
      
      ul > li:before {
        position: relative;
        left: -1.25em;
        top: -0.25em;
        content: "\25CF";
        font-size: 0.75em;
      }
      
      table {
        border-collapse: collapse;
        font-size: 1em;
        font-weight: normal;
      }
      
      th, td {
        border: 1px solid black;
        padding: 2px 5px;
        white-space: nowrap;
      }
      
      th {
        font-weight: bold;
        text-align: center;
      }
      
      /* Table cells that show the header for a group of rows */
      td[colspan="4"] {
        font-weight: bold;
        padding: 10px 5px;
      }
      
      /* the pre class uses preformatted text */
      .pre td {
        white-space: pre;
      }
      
      /* Colours for the opcodes legends */
      
      .ins0-binary {
        background-color: #8DA9E2;
      }
      
      .ins0-branch {
        background-color: #A9BFE9;
      }
      
      .ins0-move {
        background-color: #7DBD9D;
      }
      
      .ins0-other {
        background-color: #9DCEB6;
      }
      
      .ins0-float {
        background-color: #CC7C2C;
      }
      
      .ins0-stack {
        background-color: #EF7F0E;
      }
      
      .ins0-status {
        background-color: #BCAC34;
      }
      
      .ins0-unary {
        background-color: #E2CB1B;
      }
      
      .ins0-meta {
        background-color: #CC2C2F;
      }
      
      /* Colour for the highlighting of opcodes */
      .hover {
        background-color: #EEEEEE;
      }
      
      /* Default count of opcodes, these are really just markers for JS */
      .count-ins0-binary::before {
        content: "0";
      }
      
      .count-ins0-branch::before {
        content: "0";
      }
      
      .count-ins0-meta::before {
        content: "0";
      }
      
      .count-ins0-move::before {
        content: "0";
      }
      
      .count-ins0-other::before {
        content: "0";
      }
      
      .count-ins0-float::before {
        content: "0";
      }
      
      .count-ins0-stack::before {
        content: "0";
      }
      
      .count-ins0-status::before {
        content: "0";
      }
      
      .count-ins0-unary::before {
        content: "0";
      }
    </style>
    
    <script type="text/javascript">
      /*
       * Store references to the inserted css rules in a global var. Some browsers decide that JS
       * code that responds to an event that accesses stylesheet rules may cause security problems.
       * By storing the styles we need in a global var, the event code can access them directly by
       * reference, bypassing the security mechanism.
       */
      var legendStyles = {
        hover: getCSSRules(".hover")
      };
    
      function doLoad(
      ) {
        // Get the style rule names for the opcodes from the names of the .count-insX-*::before rules, where X is 0 - 7
        for (var instrSet = 0; instrSet <= 7; instrSet++) {
          var colourRegex = new RegExp("^[.]count-(ins" + instrSet + "-[^:]*)::before$");
          var colourRules = getCSSRules(
            colourRegex
          );
          
          if (colourRules) {
            var colourNames = colourRules.map(
              function(rule) {
                return colourRegex.exec(rule.selectorText)[1];
              }
            );
        
            /*
             * Create a sorted array of {cssClass: k, count: c} pairs by counting elements in the
             * opcodes table. Sort in reverse from highest count to lowest count.
             */
            var opcodeCountsToClass = colourNames.reduce(
              function(opcodeCountsToClass, value) {
                opcodeCountsToClass.push(
                  {cssClass: value, count: document.querySelectorAll('#opcodes .' + value).length}
                );
                
                return opcodeCountsToClass;
              },
              []
            ).sort(
              function(a, b) {
                return b.count - a.count;
              }
            );
                    
            /*
             * Set the counts of opcodes by overriding the .count-X::before rules with new ones.
             * Re-order the colours, so that the colours are applied from most to least popular rule,
             * by overriding the .X rules that match the .count-X::before rules.
             *
             * The background-color is provided as an rgb(r,g,b) expression regardless of how it was
             * declared in the actual rule text. Some versions of IE ignore a
             * background-color: rgb(r,g,b) rule, instead expecting background: rgb(r,g,b).
             *
             * The simplest technically correct general solution is to convert the rgb expression into
             * a hex string definition.
             *
             * While we're at it, convert array of counts and names to a map of names to count
             */
            var colourNamesIndex = 0;
            var rgbRegex = /[(]\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)/;
            var opcodeCounts = {};
            opcodeCountsToClass.forEach(
              function(value) {
                // Insert count content
                insertCSSRule(".count-" + value.cssClass + "::before{content: '" + value.count + "';}");
                
                /*
                 * Insert new colour definition.
                 * The colour value we want to use is the next one from the colourNames array.
                 * The class name to define the colour for is the class of the current value.
                 */
                var rgbParts = rgbRegex.exec(
                  getCSSRules("." + colourNames[colourNamesIndex++]).style.backgroundColor
                );
                
                var hexString = "#" +
                  (rgbParts[1] < 16 ? "0" : "") + (+rgbParts[1]).toString(16) +
                  (rgbParts[2] < 16 ? "0" : "") + (+rgbParts[2]).toString(16) +
                  (rgbParts[3] < 16 ? "0" : "") + (+rgbParts[3]).toString(16);
                
                legendStyles[value.cssClass] =
                  insertCSSRule(
                    "." + value.cssClass + "{background-color: " + hexString + ";}"
                  );
                
                opcodeCounts[value.cssClass] = value.count;
              }
            );
    
            // Get the legend rows as presented        
            var originalLegend = document.querySelectorAll("#legend" + instrSet + " tbody")[0];
            
            // Get the legend rows in the order we want
            var opcodeRows = Array.prototype.slice.call(
              originalLegend.children,
              0
            ).reduce(
              // Split each row into two for sorting
              function(split, row) {
                split.push(Array.prototype.slice.call(row.children, 0, 3));
                split.push(Array.prototype.slice.call(row.children, 3));
                return split;
              },
              []
            ).sort(
              /*
               * Sort in order of decreasing opcode counts, then by ascending name.
               * Since the table is split into two columns, one row will have a blank entry if there is an odd number of
               * elements. The blank row will not have an entry in opcodeCounts, and opcodeCounts[...] will be undefined.
               * In such cases, convert undefined to 0.
               */
              function(a, b) {
                var compare = ((b[2] && opcodeCounts[b[2].className]) || 0) - ((a[2] && opcodeCounts[a[2].className]) || 0);
                return compare !== 0 ? compare : a[0].textContent.localeCompare(b[0].textContent);
              }
            ).reduce(
              // Join pairs of rows together
              function(join, row, index, sorted) {
                if (index < sorted.length / 2) {
                  join.push(row.concat(sorted[index + sorted.length / 2]));
                }
                return join;
              },
              []
            ).forEach(
              function(oldRow, index) {
                if (index === 0) {
                  while (originalLegend.hasChildNodes()) {
                    originalLegend.removeChild(originalLegend.lastChild);
                  }
                }
              
                var newRow = document.createElement("tr");
                
                oldRow.forEach(
                  function(col) {
                    newRow.appendChild(col);
                  }
                );
                
                originalLegend.appendChild(newRow);
              }
            );
            
            // Set up events for the legend
            var dom = document.querySelectorAll("#legend" + instrSet + " tbody td[class]");
            for (var i in dom) {
              dom[i].onmouseenter = doEnterExitLegend;
              dom[i].onmouseout   = doEnterExitLegend;
            }
          }
        }
      };
      
      var insertCSSRule = (function() {
        var lastStyleSheet = document.styleSheets[document.styleSheets.length - 1];
      
        return function(rule) {
          return lastStyleSheet.cssRules[
            lastStyleSheet.insertRule(
              rule,
              lastStyleSheet.cssRules.length
            )
          ];
        };
      })(); 
            
      function getCSSRules(ruleTest, deleteFlag) {
        var isRegex = ruleTest instanceof RegExp;
        if (! isRegex) {
          ruleTest = ruleTest.toLowerCase();
        }
        var result = false;
        
        if (document.styleSheets) {
          OUTER:
          for (var i = 0; i < document.styleSheets.length; i++) {
            var styleSheet = document.styleSheets[i];
            var cssRules = styleSheet.cssRules ? styleSheet.cssRules : styleSheet.rules;
            
            for (var j in cssRules) {
              var cssRule = cssRules[j];
              
              // Not all CSS Rule objects have a selectorText property
              if (
                cssRule &&
                cssRule.selectorText &&
                (
                  (isRegex && ruleTest.test(cssRule.selectorText.toLowerCase())) ||
                  ((! isRegex) && (cssRule.selectorText.toLowerCase() === ruleTest))
                )
              ) {
                if (deleteFlag === 'delete') {
                  if (styleSheet.deleteRule) {
                    styleSheet.deleteRule(j);
                  } else {
                    styleSheet.removeRule(j);
                  }
                  
                  result = true;
                  break OUTER;
                } else if (isRegex) {
                  if (result === false) {
                    result = [cssRule];
                  } else {
                    result.push(cssRule);
                  }
                } else {
                  result = cssRule;
                  break OUTER;
                }
              }
            }
          }
        }
        
        return result;
      };
      
      function doEnterExitLegend(
        e
      ) {
        var evt = e || window.event;
        var source = evt.target || evt.srcElement;
        
        var srcRule = legendStyles[source.className];
        var dstRule = legendStyles.hover;
        
        var tmp = srcRule.style.backgroundColor;
        srcRule.style.backgroundColor = dstRule.style.backgroundColor;
        dstRule.style.backgroundColor = tmp;
      };
    </script>
  </head>
  <body onload="doLoad();">
    <h1>Instruction Set</h1>
    
    <h2>Example code</h2>
    <table>
      <thead>
        <tr>
          <th>Comment</th>
          <th>Code</th>
        </tr>
      </thead>
      <tbody class="pre">
        <tr>
<td>Read/write single 8 bit value</td>
<td>  LD    DP0,  0x010000 ; Initialize DP0
  SOS8                 ; Read/write 8 bits 
  SDAM*                ; *PTR addressing mode
  LD    PTR0, 0x0200   ; Load pointer with address DP0 + 0x0200 = 0x010200
  RD    R0,   *PTR     ; Read derefd ptr into R
  INC   R0             ; R0 = R0 + 1
  WD    *PTR, R0       ; Write R0 into derefd pointer
</td>
        </tr>
        <tr>
<td>Sum one dimensional array of 10 16-bit ints</td>
<td>  LD    DP0,  0x010000    ; Initialize DP0
  SOS16                   ; Set operand size = 16 bits
  SDAM*[]                 ; *(PTR + IX) addressing mode
  LD    PTR0, 0x0200      ; Load pointer with address DP + 0x0200 = 0x010200
  LD    IX0, (10 - 1) * 2 ; IX0 = index of first byte of last 16-bit value
  ZRO   R0                ; R0 = 0
SUM:
  ADD   R0,  *PTR         ; R0 = R0 + *(PTR0 + IX0) 
  DEC   IX0               ; IX0 = IX0 - operand size
  BPL   SUM               ; LOOP again if IX0 >= 0
                          ; R0 contains sum
</td>
        </tr>
        <tr>
          <td>Sum two dimensional array of 5 rows of 10 32-bit ints</td>
          <td>  LD    DP0,  0x010000             ; Initialize DP0
  SOS32                         ; Read/write 32 bits
  SDAM*([])                     ; *(PTR + IX0 + OFS0) addressing mode
  LD    PTR0, 0x0200            ; Load pointer with address DP0 + 0x0200 = 0x010200
  LD    IX0, (5 - 1) * (10 * 4) ; first byte of last row  
  ZRO   R0                      ; R0 = 0
ROW:
  LD    OFS0, 9 * 4             ; first byte of last int in current row
SUM:
  ADD   R0, *PTR                ; R0 = R0 + *(PTR0 + IX0 + OFS0)
  DEC   OFS                     ; OFS0 = OFS0 - operand size
  BPL   SUM                     ; continue summing row if OFS0 >= 0
  SUB   IX0, 10 * 4             ; IX0 = IX0 - length of row
  BPL   ROW                     ; sum next row if IX0 >= 0
                                ; R0 contains sum 
</td>
        </tr>
        <tr>
          <td>Access an 8-bit field of an object</td>
          <td>  LD    DP0,  0x010000 ; Initialize DP0 
  SOS8                 ; Read/write 8 bits
  SDAM*()              ; *(PTR + OFS) addresssing mode
  LD    PTR0, 0x0200   ; Load pointer with address DP + 0x0200 = 0x010200
  LD    OFS0, 0x10     ; Field offset
  RD    R0,    *PTR    ; R0 = *(DP + 0x0200 + 0x10)
  INC   R0             ; R = R + 1
  WD    *PTR, R        ; *(DP + 0x0200 + 0x10) = R
          </td>
        </tr>
        <tr>
          <td>Execute a method for an object
- Code pointer at 0x020000
- Data pointer at 0x010000
- Object at PTR0 = DP + 0x0200 = 0x010200
- First field at 0x010200 points to
  class def at CP + 0x0300 = 0x020300
- Class def method pointer at offset 0x10
  (0x020310) points to CP + 1200 = 0x021200
          </td>
          <td>  LD    DP0,  0x010000 ; Initialize DP0
  SOS32                ; Read/write 32 bits
  SCAM*(*)             ; *(CP + *(DP + PTR) + OFS)
  LD    PTR0, 0x0200   ; Load pointer with address DP + 0x0200 
  LD    OFS0, 0x10     ; Field offset of method
  RD    R0,   *PTR     ; R0 = *(CP + *(DP + 0x0200) + 0x10) = *(CP + 0x0300 + 0x10) = *020310 = 0x1200
  JSR   R0             ; Call method at CP + 0x1200 = 0x021200

0x021200:
                   ; Assume PTR0 is this object
  PSH   ST         ; Push Status
  PSH   R0         ; Push R0
  PSH   OFS0       ; Push OFS0
  SDAM*()          ; *(PTR + OFS)
  SOS8             ; Read/write 8 bits
  LD    OFS0, 0x30 ; Field offset of this object
  RD    R0,   *PTR ; R0 = *(DP + 0x0200 + 0x30) = *(0x010230)
  INC   R0         ; R0 = R0 + 1
  WD    *PTR, R0   ; Write R0 to 0x010230
  PUL OFS0         ; Pull OFS
  PUL R0           ; Pull R0
  PUL ST           ; Pull Status
  RTS              ; Return to caller 
          </td>
        </tr>
      </tbody>
    </table> 
    
    <h2>Registers</h2>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Purpose</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>R0, R0c, R1, R1c</td>
          <td>
            64 bit (un)signed general purpose registers that work in two pairs: (R0, R0c) and (R2, R1c).<br>
            Instructions that require two of these registers will work with a pair,<br>
            where one register is referred to as the complement:<br>
            R0 complement = R0c<br>
            R1 complement = R1c<br>
            When a literal or memory operand is loaded into a register, and the current operand size<br>
            is less than 64 bits, the highest bit of the operand is copied into the upper bits to extend the sign.
          </td>
        </tr>
        <tr>
          <td>DP0, DP1</td>
          <td>32 bit unsigned data pointers. DP0 is for (R0, R0c), DP1 is for (R1, R1c).</td>
        </tr>
        <tr>
          <td>CP</td>
          <td>32 bit unsigned code pointer</td>
        </tr>
        <tr>
          <td>PTR0, PTR1</td>
          <td>32 bit unsigned pointer registers: PTR0 is for (R0, R1), PTR1 is for (R2, R3)</td>
        </tr>
          <td>IX0, IX1</td>
          <td>16 bit unsigned index registers: IX0 is for (R0, R1), IX1 is for (R2, R3)</td>
        </tr>
        <tr>
          <td>PC</td>
          <td>32 bit unsigned program counter</td>
        </tr>
        <tr>
          <td>ST</td>
          <td>32 bit unsigned status register, consists of CVZNAAAA OOMMI--- SSSSSSSS UUUUUUUU:<br>
              Carry, oVerflow, Zero, Negative, Address mode, Interrupt Disable<br>
              general Register, counTer register, Operand size, Math mode, unused<br>
              There are 8 bits reserved for system use, and 8 bits reserved for user use.
          </td>
        </tr>
        <tr>
          <td>SB</td>
          <td>
            32 bit unsigned stack base register<br>
            Default location is FFFE0000 (second highest 64k)
          </td>
        </tr>
        <tr>
          <td>SP</td>
          <td>
            16 bit unsigned stack pointer register<br>
            Default value is FFFF (counts backwards as items are pushed)
          </td>
        </tr>
      </tbody>
    </table>

    <h2>ST values</h2>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>C</td>
          <td>Carry</td>
        </tr>
        <tr>
          <td>V</td>
          <td>Overflow</td>
        </tr>
        <tr>
          <td>Z</td>
          <td>Zero</td>
        </tr>
        <tr>
          <td>N</td>
          <td>Negative</td>
        </tr>
        <tr>
          <td>AAAA</td>
          <td>
            Selected DP Address Mode:<br>
            PTR = 100, OFS = 25, IX = 400, DP + 100 = 200, DP + 125 = 300, DP + 500 = 700, DP + 525 = 800<br>
            0000 = *PTR = *(DP + PTR) = *(DP + 100)<br>
            0001 = *(PTR) = *(DP + PTR + OFS) = *(DP + 125)<br>
            0010 = *[PTR] = *(DP + PTR + IX) = *(DP + 500)<br>
            0011 = *([PTR]) = *(DP + PTR + OFS + IX) = *(DP + 525)<br>
            0100 = **PTR = *(DP + *(DP + PTR)) = *(DP + *(DP + 100)) = *(DP + 200)<br>
            0101 = **(PTR): *(DP + *(DP + PTR + OFS)) = *(DP + *(DP + 100 + 25)) = *(DP + 300)<br>
            0110 = **[PTR]: *(DP + *(DP + PTR + IX)) = *(DP + *(DP + 100 + 400)) = *(DP + 700)<br>
            0111 = **([PTR]): *(DP + *(DP + PTR + OFS + IX)) = *(DP + *(DP + 100 + 25 + 400)) = *(DP + 800)<br>
            Selected CP Address Mode:<br>
            PTR = 100, OFS = 25, IX = 400, DP + 100 = 200<br>
            1000 = *PTR = *(CP + PTR) = *(CP + 100)<br>
            1001 = *(PTR) = *(CP + PTR + OFS) = *(CP + 125)<br>
            1010 = *[PTR] = *(CP + PTR + IX) = *(CP + 500)<br>
            1011 = *([PTR]) = *(CP + PTR + OFS + IX) = *(CP + 525)<br>
            1100 = **PTR = *(CP + *(DP + PTR)) = *(CP + *(DP + 100)) = *(CP + 200)<br>
            1101 = *(*PTR): *(CP + *(DP + PTR) + OFS) = *(CP + *(DP + 100) + 25) = *(CP + 225)<br>
            1110 = *[*PTR]: *(CP + *(DP + PTR) + IX) = *(CP + *(DP + 100) + 400) = *(CP + 600)<br>
            1111 = *([*PTR]): *(CP + *(DP + PTR) + OFS + IX) = *(CP + *(DP + 100) + 25 + 400) = *(CP + 625)
          </td>
        </tr>
        <tr>
          <td>OO</td>
          <td>
            Selected Operand Size<br>
            00: 8 bits<br>
            01: 16 bits<br>
            10: 32 bits<br>
            11: 64 bits
          </td>
        </tr>
        <tr>
          <td>MM</td>
          <td>
            Selected Math Mode<br>
            00 = Integer<br>
            01 = Fractional<br>
            10 = Fixed Point<br>
            11 = Floating Point<br>
            <br>
            The math mode only affects ADC, SBB, MUL, DIV, and CMP.<br>
            <br>
            Integer Mode:<br>
            Carry and Overflow are (un)signed carry and overflow.<br>
            For DIV, the quotient and remainder are stored in the selected register and complement.<br>
            For MUL, the result is twice as many bits.<br>
            For 64-bit MUL, the 128-bit product is split across (R0, R1) or (R2, R3), where R0 or R2 is highest 64 bits.<br>
            Highest bit is sign bit if using signed math.<br>
            <br>
            Fractional Mode:<br>
            A register is split into numerator (upper half) and denominator (lower half).<br>
            Numerator highest bit is sign bit if using signed math.<br> 
            Denominator is always unsigned.<br>
            If operand size is 8 bits, a 16 bit value is used.<br>
            Otherwise operates like Integer Mode.<br>
            <br>
            Fixed Point Mode:<br>
            Scaling factor and min/max range limited to decimal values:<br>
            16 bits: scaling factor = 10^-2, range = +/-99.99.<br>
            32 bits: scaling factor = 10^-4, range = +/-99,999.9999.<br>
            64 bits: scaling factor = 10^-8, range = +/-99,999,999,999.99999999.<br>
            If operand size is 8 bits, a 16 bit value is used.<br>
            Otherwise operates like Integer Mode.<br>
            <br>
            Floating Point Mode:<br>
            Carry = NaN.<br>
            Overflow = Divide By Zero.<br>
            ZN have usual meaning.<br>
            No unsigned math.<br>
            Implemented as IEEE 754 Half Precision (16 bits), Single Precision (32 bits), or Double Precision (64 bits).<br>
            If operand size is 8 bits, a 16 bit value is used.
          </td>
        </tr>
        <tr>
          <td>I</td>
          <td>Interrupt Disable</td>
        </tr>
      </tbody>
    </table>
    
    <h2>Instructions</h2>
    <ul>
      <li>R = Selected general purpose register</li>
      <li>Rc = Complement of selected general purpose register</li>
      <li>Rx, Ry is either (R0, R1) or (R2, R3)</li>
      <li>DP = Selected data pointer register</li>
      <li>PTR = Selected pointer register</li>
      <li>*PTR = Selected pointer register data in current addressing mode</li>
      <li>OFS = Selected offset register</li>
      <li>IX = Selected index register</li>
      <li>IS = Selected index step register</li>
      <li>CTR = Selected counter register</li>
      <li>CS = Selected counter step register</li>
      <li>OP1,OP2 = Operands of last CMP instruction</li>
      <li>Ir = Input register or data</li>
      <li>Or = Output register</li>
      <li>U,S,O = (U)n(S)igned (O)perand of current size</li>
      <li>U8,U16,U32,U64,S8,S16,S32,S64 = (U)n(S)signed operand of specific size</li>
      <li>H = Highest bit, depends on operand size (bit 7, 15, 31, or 63)</li>
      <li>An apostrophe indicates the value after the instruction has executed</li>
    </ul>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Description</th>
          <th>Modes</th>
          <th>Status flags</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td colspan="4">Binary (<span class="count-ins0-binary"></span> opcodes)</td>
        </tr>
        <tr>
          <td>ADC</td>
          <td>Add R with Rc and Carry</td>
          <td>
            R = R + Rc + C<br>
            C = 1 if (H(R) = 1 or H(Rc) = 1) and (H(R + Rc + C) = 0)<br>
            V = 1 if (H(R) = H(Rc)) and (H(R) != H(R + Rc + C))
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>ADD</td>
          <td>Add R with Rc</td>
          <td>
            R = R + Rc<br>
            C = 1 if (H(R) = 1 or H(Rc) = 1) and (H(R + Rc) = 0)<br>
            V = 1 if (H(R) = H(Rc)) and (H(R) != H(R + Rc))
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>AND</td>
          <td>Bitwise AND R with Rc</td>
          <td>
            R = R ∧ Rc
          </td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td>CMP</td>
          <td>Compare R with Rc</td>
          <td>
            CMP R, Rc<br>
            C = 1 if R &gt;= Rc unsigned<br>
            V = 1 if R &gt;= Rc signed<br>
            Z = 1 if R = Rc
          </td>
          <td>CVZ----- --------</td>
        </tr>
        <tr>
          <td>DIVS</td>
          <td>Signed Division with R and Rc</td>
          <td>
            R' = R / Rc<br>
            In integer mode:<br>
            Rc' = R mod Rc<br>
            N is sign of quotient and V is sign of remainder<br>
            If denominator is zero execute *FFFFFFFC interrupt with R0 = 3 (division by zero)<br>
            In floating point mode:<br>
            C and V are set<br>
            If denominator is zero, result is +/- infinity
          </td>
          <td>-VZN---- --------</td>
        </tr>
        <tr>
          <td>DIVU</td>
          <td>Unsigned Division with R and Rc</td>
          <td>
            R' = R / Rc<br>
            In integer mode:<br>
            Rc' = R mod Rc<br>
            N is sign of quotient and V is sign of remainder<br>
            If denominator is zero execute *FFFFFFFC interrupt with R0 = 3 (division by zero)<br>
            In floating point mode:<br>
            Division is still signed<br>
            C and V are set<br>
            If denominator is zero, result is +/- infinity
          </td>
          <td>
            -VZN---- --------<br>
            C is set in floating point mode
          </td>
        </tr>
        <tr>
          <td>MULS</td>
          <td>Signed Multiply with R and Rc</td>
          <td>
          	In integer mode:<br>
            When OO = 00, 01, or 10:<br>
            R = R * Rc<br>
            When OO = 11:<br>
            R, Rc = R * Rc<br>
            R is lower 64 bits, Rc is upper 64 bits<br>
            In floating point mode:<br>
            R = R * Rc
          </td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td>MULU</td>
          <td>Unsigned Multiply with R and Rc</td>
          <td>
          	In integer mode:<br>
            When OO = 00, 01, or 10:<br>
            R = R * Rc<br>
            When OO = 11:<br>
            R, Rc = R * Rc<br>
            R is lower 64 bits, Rc is upper 64 bits<br>
            In floating point mode:<br>
            Multiplication is still signed<br>
            R = R * Rc
          </td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td>OR</td>
          <td>Bitwise OR R with Rc</td>
          <td>
            R = R ∨ Rc
          </td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td>SHA</td>
          <td>Shift R bits right Rc times, arithmetic</td>
          <td>
            R = R &gt;&gt; Rc<br>
            Highest Rc bits of R' = H(R), causing the sign of R to remain the same<br>
            C = 1 if any of the lower Rc bits of R are set
          </td>
          <td>C-ZN---- --------</td>
        </tr>
        <tr>
          <td>SHL</td>
          <td>Shift R bits left Rc times</td>
          <td>
            R = R &lt;&lt; Rc<br>
            C = 1 if any of the upper Rc bits of R are set
          </td>
          <td>C-ZN---- --------</td>
        </tr>
        <tr>
          <td>SHR</td>
          <td>Shift R bits right Rc times</td>
          <td>
            R = R &gt;&gt; Rc<br>
            C = 1 if any of the lower Rc bits of R are set
          </td>
          <td>C-ZN---- --------</td>
        </tr>
        <tr>
          <td>SBB</td>
          <td>Subtract R with Rc and Borrow (Carry)</td>
          <td>
            R = R - Rc - C<br>
            C = 1 if R' > R unsigned<br>
            V = 1 if (H(R') != H(R)) and (H(Rc) = H(R'))<br>
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>SUB</td>
          <td>Subtract R with Rc</td>
          <td>
            R = R - Rc<br>
            C = 1 if R' > R unsigned<br>
            V = 1 if (H(R') != H(R)) and (H(Rc) = H(R'))<br>
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>XOR</td>
          <td>Bitwise XOR with R and Rc</td>
          <td>
            R = R ⊻ Rc<br>
          </td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td colspan="4">Branch and Jump (<span class="count-ins0-branch"></span> opcodes)</td>
        </tr>
        <tr>
          <td>BCC (BLTU, BNANC)</td>
          <td>Branch on carry clear (R &lt; Rc unsigned, FP result is not NaN)</td>
          <td>
            PC = PC + S8 if C = 0
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BCS (BGEU, BNANS)</td>
          <td>Branch on carry set (R &gt;= Rc unsigned, FP result is NaN)</td>
          <td>
            PC = PC + S8 if C = 1
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BVC (BLTS, BDZC)</td>
          <td>Branch on overflow clear (R &lt; Rc signed, Divide by zero clear)</td>
          <td>
            PC = PC + S8 if V = 0
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BVS (BGES, BDZS)</td>
          <td>Branch on overflow set (R &gt;= Rc signed, Divide by zero set)</td>
          <td>
            PC = PC + S8 if V = 1
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BEQ</td>
          <td>Branch on equal to zero (R = Rc)</td>
          <td>
            PC = PC + S8 if Z = 1
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BNE</td>
          <td>Branch on not equal to zero (R != Rc)</td>
          <td>
            PC = PC + S8 if Z = 0
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BMI</td>
          <td>Branch on negative</td>
          <td>
            PC = PC + S8 if N = 1
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BPL</td>
          <td>Branch on positive (or zero)</td>
          <td>
            PC = PC + S8 if N = 0
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>JMA</td>
          <td>Jump to an absolute unsigned address</td>
          <td>
            PC = (lowest 32 bits of R)<br>
            PC = U32
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>JMP</td>
          <td>Jump to relative signed address</td>
          <td>
            PC = PC + (lowest 16 bits of R)<br>
            PC = PC + S16
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>JSA</td>
          <td>Jump to subroutine at an absolute unsigned address</td>
          <td>
            Push PC; PC = (lowest 32 bits of R)<br>
            Push PC; PC = U32
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>JSR</td>
          <td>Jump to subroutine at a relative signed address</td>
          <td>
            Push PC; PC = PC + (lowest 16 bits of R)<br>
            Push PC; PC = PC + S16
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>RTS</td>
          <td>Return from subroutine</td>
          <td>
            Pull PC<br>
            SP = SP + U8; Pull PC<br>
            A hardware error occurs if the stack underflows
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>RTI</td>
          <td>Return from interrupt</td>
          <td>
            PUL R0<br>
            PUL R1<br>
            PUL R2<br>
            PUL R3<br>
            PUL DP0<br>
            PUL PTR0<br>
            PUL OFS0<br>
            PUL IX0<br>
            PUL DP1<br>
            PUL PTR1<br>
            PUL OFS1<br>
            PUL IX1<br>
            PUL CP<br>
            PUL ST<br>
            PUL PC<br>
            A hardware error occurs if the stack underflows
          </td>
          <td>CVZNAAAI OOMM----</td>
        </tr>
        <tr>
          <td colspan="4">Floating Point (<span class="count-ins0-float"></span> opcodes)</td>
        </tr>
        <tr>
          <td>F2SF</td>
          <td>Signed integer to floating point</td>
          <td>
            R(floating point) = R(signed int)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FABS</td>
          <td>Absolute value</td>
          <td>
            R = ABS(R)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FACS</td>
          <td>Arc cosine</td>
          <td>
            R = ARCCOS(Rc)
          </td>
          <td>--Z---- --------</td>
        </tr>
        <tr>
          <td>FASN</td>
          <td>Arc sine</td>
          <td>
            R = ARCSIN(Rc)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FATN</td>
          <td>Arc tangent</td>
          <td>
            R = ARCTAN(Rc)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FCEL</td>
          <td>Ceiling</td>
          <td>
            R = CEIL(R)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FCOS</td>
          <td>Cosine</td>
          <td>
            R = COS(Rc)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FF2S</td>
          <td>Floating point to signed integer</td>
          <td>
            R(signed int) = R(floating point)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FF2U</td>
          <td>Floating point to unsigned integer</td>
          <td>
            R(unsigned int) = R(floating point)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FFLR</td>
          <td>Floor</td>
          <td>
            R = FLOOR(R)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FLOG</td>
          <td>Logarithm base 10</td>
          <td>
            R = LOG10(Rc)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FNLG</td>
          <td>Logarithm base E</td>
          <td>
            R = LOGE(Rc)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FPOW</td>
          <td>Power</td>
          <td>
            R = R ^ Rc
          </td>
          <td>-VZN--- --------</td>
        </tr>
        <tr>
          <td>FSIN</td>
          <td>Sine</td>
          <td>
            R = SIN(Rc)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FSQR</td>
          <td>Square root</td>
          <td>
            R = √Rc
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FTAN</td>
          <td>Tangent</td>
          <td>
            R = TAN(Rc)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FU2F</td>
          <td>Unsigned integer to floating point</td>
          <td>
            R(floating point) = R(unsigned int)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td colspan="4">Move (<span class="count-ins0-move"></span> opcodes)</td>
        </tr>
        <tr>
          <td>LD</td>
          <td>Load destination register with literal operand</td>
          <td>
            LD R0, O<br>
            LD R1, O<br>
            LD R2, O<br>
            LD R3, O<br>
            LD DP0, R0<br>
            LD PTR0, U32<br>
            LD OFS0, U16<br>
            LD IX0, U16<br>
            LD IS0, S16<br>
            LD CTR0, U32<br>
            LD CS0, U16<br>
            LD DP1, U32<br>
            LD PTR1, U32<br>
            LD OFS1, U16<br>
            LD IX1, U16<br>
            LD IS1, S16<br>
            LD CTR1, U32<br>
            LD CS1, U16<br>
            LD SB, U32<br>
            LD SP, U32
          </td>
          <td>
            --ZN---- --------<br>
          </td>
        </tr>
        <tr>
          <td>RD</td>
          <td>Read destination register with register or memory</td>
          <td>
            RD R0, R1<br>
            RD R0, DP0<br>
            RD R0, PTR0<br>
            RD R0, *PTR0<br>
            RD R0, OFS0<br>
            RD R0, IX0<br>
            RD R0, IS0<br>
            RD R0, CTR0<br>
            RD R0, CS0<br>
            RD R2, R3<br>
            RD R2, DP1<br>
            RD R2, PTR1<br>
            RD R2, *PTR1<br>
            RD R2, OFS1<br>
            RD R2, IX1<br>
            RD R2, IS1<br>
            RD R2, CTR1<br>
            RD R2, CS1<br>
            RD R0, ST<br>
            RD R0, SB<br>
            RD R0, SP<br>
            RD R0, *SP[U8]<br>
            RD R0, M; M = absolute memory address
          </td>
          <td>
            --ZN---- --------<br>
            RD R0, ST does not affect flags
          </td>
        </tr>
        <tr>
          <td>WD</td>
          <td>Write destination register with source register or memory</td>
          <td>
            WD R1, R0<br>
            WD DP0, R0<br>
            WD PTR0, R0<br>
            WD *PTR0, R0<br>
            WD OFS0, R0<br>
            WD IX0, R0<br>
            WD IS0, R0<br>
            WD CTR0, R0<br>
            WD CS0, R0<br>
            WD R3, R2<br>
            WD DP1, R2<br>
            WD PTR1, R2<br>
            WD *PTR1, R2<br>
            WD OFS1, R2<br>
            WD IX1, R2<br>
            WD IS1, R2<br>
            WD CTR1, R2<br>
            WD CS1, R2<br>
            WD ST, R0<br>
            WD SB, R0<br>
            WD SP, R0<br>
            WD *SP[U8], R0<br>
            WD M, R0; M = absolute memory address
          </td>
          <td>
            --ZN---- --------<br>
            WD ST, R0 overwrites all flags
          </td>
        </tr>
        <tr>
          <td>SWP</td>
          <td>Swap data</td>
          <td>
            SWP R0, R1<br>
            SWP R0, R2<br>
            SWP R0, R3<br>
            SWP R2, R3<br>
            SWP R0, DP0<br>
            SWP R0, PTR0<br>
            SWP R0, *PTR0<br>
            SWP R0, OFS0<br>
            SWP R0, IX0<br>
            SWP R0, IS0<br>
            SWP R0, CTR0<br>
            SWP R0, CS0<br>
            SWP R2, DP1<br>
            SWP R2, PTR1<br>
            SWP R2, *PTR1<br>
            SWP R2, OFS1<br>
            SWP R2, IX1<br>
            SWP R2, IS1<br>
            SWP R2, CTR1<br>
            SWP R2, CS1<br>
            SWP R0, *SP[U8]<br>
            SWP R2, *SP[U8]<br>
            SWP R0, M; M = absolute memory address
            SWP R1, M; M = absolute memory address
          </td>
          <td>
            --ZN---- --------<br>
          </td>
        </tr>
        <tr>
          <td colspan="4">Other (<span class="count-ins0-other"></span> opcodes)</td>
        </tr>
        <tr>
          <td>NOP</td>
          <td>No operation</td>
          <td>Waste a CPU cycle</td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td colspan="4">Stack (<span class="count-ins0-stack"></span> opcodes)</td>
        </tr>
        <tr>
          <td>PSH</td>
          <td>Push on the stack</td>
          <td>
            If SP - register size &lt; 0 execute *FFFFFFFC interrupt with R0 = 1 (stack overflow)<br>
            *SP = register<br>
            SP = SP - register size<br>
            <br>
            PSH R0<br>
            PSH R1<br>
            PSH R2<br>
            PSH R3<br>
            PSH DP0<br>
            PSH PTR0<br>
            PSH OFS0<br>
            PSH IX0<br>
            PSH IS0<br>
            PSH CTR0<br>
            PSH CS0<br>
            PSH DP1<br>
            PSH PTR1<br>
            PSH OFS1<br>
            PSH IX1<br>
            PSH IS1<br>
            PSH CTR1<br>
            PSH CS1<br>
            PSH ST<br>
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>PUL</td>
          <td>Pull off the stack</td>
          <td>
            If SP + register size &gt; FFFFFFFF execute *FFFFFFFC interrupt with R0 = 2 (stack underflow)<br>
            SP = SP + register size<br>
            register = *SP<br>
            <br>
            PUL R0<br>
            PUL R1<br>
            PUL R2<br>
            PUL R3<br>
            PUL DP0<br>
            PUL PTR0<br>
            PUL OFS0<br>
            PUL IX0<br>
            PUL IS0<br>
            PUL CTR0<br>
            PUL CS0<br>
            PUL DP1<br>
            PUL PTR1<br>
            PUL OFS1<br>
            PUL IX1<br>
            PUL IS1<br>
            PUL CTR1<br>
            PUL CS1<br>
            PUL ST<br>
          </td>
          <td>
            -------- --------<br>
            PUL ST affects all flags
          </td>
        </tr>
        <tr>
          <td>SSP</td>
          <td>Subtract from stack pointer</td>
          <td>
            If SP - U8 &lt; 0 execute *FFFFFFFC interrupt with R0 = 1 (stack overflow)<br>
            SP = SP - U8
          </td>
          <td>--------- --------</td>
        </tr>
        <tr>
          <td colspan="4">Status (<span class="count-ins0-status"></span> opcodes)</td>
        </tr>
        <tr>
          <td>CLC</td>
          <td>Clear carry flag (Clear NaN)</td>
          <td>Set C = 0</td>
          <td>0------- --------</td>
        </tr>
        <tr>
          <td>SEC</td>
          <td>Set carry flag (Set NaN)</td>
          <td>Set C = 1</td>
          <td>1------- --------</td>
        </tr>
        <tr>
          <td>SDAM*</td>
          <td>Select data address mode 0: *(DP + PTR)</td>
          <td>Set AAAA = 0</td>
          <td>----0000 --------</td>
        </tr>
        <tr>
          <td>SDAM*()</td>
          <td>Select data address mode 1: *(DP + PTR + OFS)</td>
          <td>Set AAAA = 1</td>
          <td>----0001 --------</td>
        </tr>
        <tr>
          <td>SDAM*[]</td>
          <td>Select data address mode 2: *(DP + PTR)</td>
          <td>Set AAAA = 2</td>
          <td>----0010 --------</td>
        </tr>
        <tr>
          <td>SDAM*([])</td>
          <td>Select data address mode 3: *(DP + PTR + IX + OFS)</td>
          <td>Set AAAA = 3</td>
          <td>----0011 --------</td>
        </tr>
        <tr>
          <td>SDAM**</td>
          <td>Select data address mode 4: *(DP + *(DP + PTR))</td>
          <td>Set AAAA = 4</td>
          <td>----0100 --------</td>
        </tr>
        <tr>
          <td>SDAM**()</td>
          <td>Select data address mode 5: *(DP + *(DP + PTR + OFS))</td>
          <td>Set AAAA = 5</td>
          <td>----0101 --------</td>
        </tr>
        <tr>
          <td>SDAM**[]</td>
          <td>Select data address mode 6: *(DP + (*DP + PTR + IX))</td>
          <td>Set AAAA = 6</td>
          <td>----0110 --------</td>
        </tr>
        <tr>
          <td>SDAM**([])</td>
          <td>Select data address mode 7: *(DP + (*DP + PTR + OFS + IX))</td>
          <td>Set AAAA = 7</td>
          <td>----0111 --------</td>
        </tr>
        <tr>
          <td>SCAM*</td>
          <td>Select code address mode 8: *(CP + PTR)</td>
          <td>Set AAAA = 8</td>
          <td>----1000 --------</td>
        </tr>
        <tr>
          <td>SCAM*()</td>
          <td>Select code address mode 9: *(CP + PTR + OFS)</td>
          <td>Set AAAA = 9</td>
          <td>----1001 --------</td>
        </tr>
        <tr>
          <td>SCAM*[]</td>
          <td>Select code address mode 10: *(CP + PTR + IX)</td>
          <td>Set AAAA = 10</td>
          <td>----1010 --------</td>
        </tr>
        <tr>
          <td>SCAM*([])</td>
          <td>Select code address mode 11: *(CP + PTR + OFS + IX)</td>
          <td>Set AAAA = 11</td>
          <td>----1011 --------</td>
        </tr>
        <tr>
          <td>SCAM**</td>
          <td>Select code address mode 12: *(CP + *(DP + PTR))</td>
          <td>Set AAAA = 12</td>
          <td>----1100 --------</td>
        </tr>
        <tr>
          <td>SCAM*(*)</td>
          <td>Select code address mode 13: *(CP + *(DP + PTR) + OFS)</td>
          <td>Set AAAA = 13</td>
          <td>----1101 --------</td>
        </tr>
        <tr>
          <td>SCAM*[*]</td>
          <td>Select code address mode 14: *(CP + *(DP + PTR) + IX)</td>
          <td>Set AAAA = 14</td>
          <td>----1110 --------</td>
        </tr>
        <tr>
          <td>SCAM*([*])</td>
          <td>Select code address mode 15: *(CP + *(DP + PTR) + OFS + IX)</td>
          <td>Set AAAA = 15</td>
          <td>----1111 --------</td>
        </tr>
        <tr>
          <td>SOS0</td>
          <td>Select operand size 0 (8 bits)</td>
          <td>Set OO = 0</td>
          <td>-------- 00------</td>
        </tr>
        <tr>
          <td>SOS1</td>
          <td>Select operand size 1 (16 bits)</td>
          <td>Set OO = 1</td>
          <td>-------- 01------</td>
        </tr>
        <tr>
          <td>SOS2</td>
          <td>Select operand size 2 (32 bits)</td>
          <td>Set OO = 2</td>
          <td>-------- 10------</td>
        </tr>
        <tr>
          <td>SOS3</td>
          <td>Select operand size 3 (64 bits)</td>
          <td>Set OO = 3</td>
          <td>-------- 11------</td>
        </tr>
        <tr>
          <td>SMM0</td>
          <td>Select math mode 0</td>
          <td>Set MM = 0</td>
          <td>-------- --00----</td>
        </tr>
        <tr>
          <td>SMM1</td>
          <td>Select math mode 1</td>
          <td>Set MM = 1</td>
          <td>-------- --01----</td>
        </tr>
        <tr>
          <td>SMM2</td>
          <td>Select math mode 2</td>
          <td>Set MM = 2</td>
          <td>-------- --10----</td>
        </tr>
        <tr>
          <td>SMM3</td>
          <td>Select math mode 3</td>
          <td>Set MM = 3</td>
          <td>-------- --11----</td>
        </tr>
        <tr>
          <td>CLI</td>
          <td>Clear interrupt disable flag</td>
          <td>Set I = 0</td>
          <td>-------- ----0---</td>
        </tr>
        <tr>
          <td>SEI</td>
          <td>Set interrupt disable flag</td>
          <td>Set I = 1</td>
          <td>-------- ----1---</td>
        </tr>
        <tr>
          <td colspan="4">Unary (<span class="count-ins0-unary"></span> opcodes)</td>
        </tr>
        <tr>
          <td>DEC</td>
          <td>Decrement</td>
          <td>
            R0 = R0 - 1<br>
            *PTR0 = *PTR0 - 1<br>
            R2 = R2 - 1<br>
            *PTR1 = *PTR1 - 1<br>
            C = 1 if H(R/*PTR) = 0 and (H'(R/*PTR) = 1)<br>
            V = 1 if (H(R/*PTR) = 1) and (H'(R/*PTR) = 0)<br>
            Only the Zero flag is set for counters
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>INC</td>
          <td>Increment</td>
          <td>
            R0 = R0 + 1<br>
            *PTR0 = *PTR0 + 1<br>
            R2 = R2 + 1<br>
            *PTR2 = *PTR2 + 1<br>
            C = 1 if (H(R/*PTR) = 1) and (H'(R/*PTR) = 0)<br>
            V = 1 if (H(R/*PTR) = 0) and (H'(R/*PTR) = 1)
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>NEG</td>
          <td>Negate</td>
          <td>
            R0 = -R0<br>
            *PTR0 = -*PTR0<br>
            R2 = -R2<br>
            *PTR2 = -*PTR2
          </td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td>NG1</td>
          <td>Set to -1</td>
          <td>
            R0 = -1<br>
            *PTR0 = -1 (current operand size)<br>
            R2 = -1<br>
            IS0 = -1<br>
            *PTR2 = -1 (current operand size)<br>
            IS1 = -1
          </td>
          <td>--ZN----- --------</td>
        </tr>
        <tr>
          <td>NOT</td>
          <td>Bitwise NOT</td>
          <td>
            R0 = ~R0<br>
            *PTR0 = ~*PTR0<br>
            R2 = ~R2<br>
            *PTR2 = ~*PTR2
          </td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td>NXT</td>
          <td>Add step to register</td>
          <td>
            OFS0 = OFS0 + operand size (1 - 4)<br>
            IX0 = IX0 + IS0<br>
            CTR0 = CTR1 - CS1<br>
            OFS1 = OFS1 + operand size (1 - 4)<br>
            IX1 = IX1 + IS1<br>
            CTR1 = CTR1 - CS1<br>
            CVZN are set the same as for ADD/SUB
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>ONE</td>
          <td>Set to 1</td>
          <td>
            R0 = 1<br>
            IS0 = 1<br>
            CS0 = 1<br>
            R2 = 1<br>
            IS2= 1<br>
            CS2 = 1<br>
          </td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td>SHA</td>
          <td>Arithmetic shift right</td>
          <td>
            R0 = R0 &gt;&gt; R1<br>
            R2 = R2 &gt;&gt; R3<br>
            H'(Or) = H(Or)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>SHL</td>
          <td>Shift left with carry</td>
          <td>
            R0 = R0 &lt;&lt; R1<br>
            R2 = R2 &lt;&lt; R3<br>
            BIT0'(Or) = C<br>
            C = H(Or)
          </td>
          <td>C-ZN--- --------</td>
        </tr>
        <tr>
          <td>SHR</td>
          <td>Shift right with carry</td>
          <td>
            R0 = R0 &gt;&gt; R1<br>
            R2 = R2 &gt;&gt; R3<br>
            H'(Or) = C<br>
            C = BIT0(Or)
          </td>
          <td>C-ZN--- --------</td>
        </tr>
        <tr>
          <td>ZRO</td>
          <td>Set to 0</td>
          <td>
            R0 = 0<br>
            OFS0 = 0<br>
            IX0 = 0<br>
            R2 = 0<br>
            OFS1 = 0<br>
            IX1 = 0<br>
          </td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td colspan="4">Meta (<span class="count-ins0-meta"></span> opcodes)</td>
        </tr>
        <tr>
          <td>LOOP</td>
          <td>Load IX, IS, CTR, CS registers</td>
          <td>
            LOOP numberTimes<br>
            LOOP numberTimes, indexStep<br>
            IX0 = 0; IS0 = 1 or provided indexStep; CTR0 = numberTimes; CS0 = 1
            IX1 = 0; IS1 = 1 or provided indexStep; CTR1 = numberTimes; CS1 = 1
          </td>
          <td>-------- --------</td>
        </tr>
      </tbody>
    </table>
    
    <h2>Branches and Jumps</h2>
    <p>
      All relative branches and jumps are relative to the address of the first byte of the next instruction.
      Branches use 8-bit operands, while jumps use 16-bit operands.
      Relative to the first byte of the branch itself, the 8-bit operand allows a jump in the range of [-126, 129],
      while a 16-bit operand allows a jump in the range of [-32765, 32770].
    </p>
    <p>
      JMA/JSA Allow jumps with an absolute 32-bit usigned address to any code in the system.
    </p>
    
    <h2>Interrupts</h2>
    <ul>
      <li>Interrupts can only occur by hardware, there is no instruction to invoke an interrupt.</li>
      <li>Interrupts can only occur when the Interrupt Disabled flag is clear. Any routine should set this flag
        at the start of a critical section, and clear it at the end.
      </li>
      <li>Interrupts save all registers and must end with an RTI instruction to pull all registers and resume
        execution at the interrupted code.
      </li>
      <li>Interrupts need a defined memory address to contain the pointer to the interrupt routine.
        An optional interrupt begins with the pointer set to 0, a required interrupt will
        initialize the pointer to a default routine. 
      </li>
    </ul>
    
    <h2>General Information</h2>
    <ol>
      <li>The processor is little endian - the highest byte is stored first, the lowest byte last</li>
      <li>The stack is 64k in size, the default range = FFFE0000 thru FFFEFFFF</li>
      <li>OS routines should be located in FFFF0000 thru FFFFFFFB</li>
      <li>Reset/error interrupt pointer is FFFFFFFC thru FFFFFFFF</li>
      <li>Since there is no software interrupt instruction, use JSA to call an address containing a JMA instruction that
        calls the actual routine at an OS defined address. Such a jump table provides well-known addresses for users to
        call OS routines, while allowing the OS routines to be moved around as they are updated.
      </li>
    </ol>
    
    <h2>Startup information</h2>
    <ul>
      <li>A reset executes *FFFFFFFC interrupt with R0 = 0.</li>
      <li>All other registers have undefined values on reset. A reset could occur at anytime, in which case the registers will
        still hold their current values after the reset.
      </li>
      <li>This same interrupt has other values for R0 for error conditions (see Instructions)</li>
    </ul>
    
    <h2>Opcodes</h2>
    <ul>
      <li>All unused opcodes in rows 0 thru D are reserved for future use.</li>
      <li>All opcodes in rows E and F are available for implementation use.</li>
      <li>Opcodes cannot be user defined.</li>
    </ul>
    <p>Legend</p>
    <p>Note: roll mouse over the colours in the legend to highlight the instructions in the table.</p>
    <table id="legend0">
      <thead>
        <tr>
          <th>Instruction Group</th>
          <th>Opcodes</th>
          <th>Colour</th>
          <th>Instruction Group</th>
          <th>Opcodes</th>
          <th>Colour</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Binary</td>
          <td><span class="count-ins0-binary"></span></td>
          <td class="ins0-binary"></td>
          
          <td>Branch and Jump</td>
          <td><span class="count-ins0-branch"></span></td>
          <td class="ins0-branch"></td>
        </tr>
        <tr>
          <td>Meta</td>
          <td><span class="count-ins0-meta"></span></td>
          <td class="ins0-meta"></td>

          <td>Move and swap</td>
          <td><span class="count-ins0-move"></span></td>
          <td class="ins0-move"></td>
        </tr>          
          <td>Other</td>
          <td><span class="count-ins0-other"></span></td>
          <td class="ins0-other"></td>

          <td>Pointer</td>
          <td><span class="count-ins0-float"></span></td>
          <td class="ins0-float"></td>
        </tr>
        <tr>
          <td>Stack</td>
          <td><span class="count-ins0-stack"></span></td>
          <td class="ins0-stack"></td>
                              
          <td>Status</td>
          <td><span class="count-ins0-status"></span></td>
          <td class="ins0-status"></td>
        </tr>
        <tr>
          <td>Unary</td>
          <td><span class="count-ins0-unary"></span></td>
          <td class="ins0-unary"></td>
        </tr>
      </tbody>
    </table>
    
    <p>Opcodes</p>
    <table id="opcodes">
      <thead>
        <tr>
          <th></th>
          <th>0</th>
          <th>1</th>
          <th>2</th>
          <th>3</th>
          <th>4</th>
          <th>5</th>
          <th>6</th>
          <th>7</th>
          <th>8</th>
          <th>9</th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
          <th>D</th>
          <th>E</th>
          <th>F</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td class="ins0-binary">ADD R,Rc</td>
          <td class="ins0-binary">ADD R,*PTR</td>
          <td class="ins0-binary">AND R,Rc</td>
          <td class="ins0-binary">AND R,*PTR</td>
          <td class="ins0-binary">CMP R,Rc</td>
          <td class="ins0-binary">CMP R,*PTR</td>
          <td class="ins0-binary">DIV R,Rc</td>
          <td class="ins0-binary">DIV R,*PTR</td>
          <td class="ins0-binary">MUL R,Rc</td>
          <td class="ins0-binary">MUL R,*PTR</td>
          <td class="ins0-binary">OR R,Rc</td>
          <td class="ins0-binary">OR R,*PTR</td>
          <td class="ins0-binary">SHA R,Rc</td>
          <td class="ins0-binary">SHA R,U8</td>
          <td class="ins0-binary">SHL R,Rc</td>
          <td class="ins0-binary">SHL R,U8</td>
        </tr>
        <tr>
          <th>1</th>
          <td class="ins0-binary">SHR R,Rc</td>
          <td class="ins0-binary">SHR R,U8</td>
          <td class="ins0-binary">SUB R,Rc</td>
          <td class="ins0-binary">SUB R,*PTR</td>
          <td class="ins0-binary">XOR R,Rc</td>
          <td class="ins0-binary">XOR R,*PTR</td>
          <td class="ins0-branch">BCC S8</td>
          <td class="ins0-branch">BCS S8</td>
          <td class="ins0-branch">BVC S8</td>
          <td class="ins0-branch">BVS S8</td>
          <td class="ins0-branch">BEQ S8</td>
          <td class="ins0-branch">BNE S8</td>
          <td class="ins0-branch">BMI S8</td>
          <td class="ins0-branch">BPL S8</td>
          <td class="ins0-branch">JMA R</td>
          <td class="ins0-branch">JMA U32</td>
        </tr>
        <tr>
          <th>2</th>
          <td class="ins0-branch">JMP R</td>
          <td class="ins0-branch">JMP S16</td>
          <td class="ins0-branch">JSA R</td>
          <td class="ins0-branch">JSA U32</td>
          <td class="ins0-branch">JSR R</td>
          <td class="ins0-branch">JSR S16</td>
          <td class="ins0-branch">RTS</td>
          <td class="ins0-branch">RTS U8</td>
          <td class="ins0-branch">RTI</td>
          <td class="ins0-float">F2SF</td>
          <td class="ins0-float">FABS</td>
          <td class="ins0-float">FACS</td>
          <td class="ins0-float">FASN</td>
          <td class="ins0-float">FATN</td>
          <td class="ins0-float">FCEL</td>
          <td class="ins0-float">FCOS</td>
        </tr>
        <tr>
          <th>3</th>
          <td class="ins0-float">FF2S</td>
          <td class="ins0-float">FF2U</td>
          <td class="ins0-float">FFLR</td>
          <td class="ins0-float">FLOG</td>
          <td class="ins0-float">FNLG</td>
          <td class="ins0-float">FPOW</td>
          <td class="ins0-float">FSIN</td>
          <td class="ins0-float">FSQR</td>
          <td class="ins0-float">FTAN</td>
          <td class="ins0-float">FU2F</td>
          <td class="ins0-move">LD R,O</td>
          <td class="ins0-move">LD PTR,U32</td>
          <td class="ins0-move">LD OFS,U16</td>
          <td class="ins0-move">LD IX,U16</td>
          <td class="ins0-move">LD IS,S16</td>
          <td class="ins0-move">LD CTR,U32</td>
        </tr>
        <tr>
          <th>4</th>
          <td class="ins0-move">LD CS,U16</td>
          <td class="ins0-move">LD DP,U32</td>
          <td class="ins0-move">LD SB,U32</td>
          <td class="ins0-move">LD SP,U32</td>
          <td class="ins0-move">RD R,Rc</td>
          <td class="ins0-move">RD R,PTR</td>
          <td class="ins0-move">RD R,*PTR</td>
          <td class="ins0-move">RD R,OFS</td>
          <td class="ins0-move">RD R,IX</td>
          <td class="ins0-move">RD R,IS</td>
          <td class="ins0-move">RD R,CTR</td>
          <td class="ins0-move">RD R,CS</td>
          <td class="ins0-move">RD R,DP</td>
          <td class="ins0-move">RD R,ST</td>
          <td class="ins0-move">RD R,SB</td>
          <td class="ins0-move">RD R,SP</td>
        </tr>
        <tr>
          <th>5</th>
          <td class="ins0-move">RD R,*SP[U8]</td>
          <td class="ins0-move">RD R,M</td>
          <td class="ins0-move">WD R,Rc</td>
          <td class="ins0-move">WD R,PTR</td>
          <td class="ins0-move">WD R,*PTR</td>
          <td class="ins0-move">WD R,OFS</td>
          <td class="ins0-move">WD R,IX</td>
          <td class="ins0-move">WD R,IS</td>
          <td class="ins0-move">WD R,CTR</td>
          <td class="ins0-move">WD R,CS</td>
          <td class="ins0-move">WD R,DP</td>
          <td class="ins0-move">WD R,ST</td>
          <td class="ins0-move">WD R,SB</td>
          <td class="ins0-move">WD R,SP</td>
          <td class="ins0-move">WD R,*SP[U8]</td>
          <td class="ins0-move">WD R,M</td>
        </tr>
        <tr>
          <th>6</th>
          <td class="ins0-move">SWP R,Rc</td>
          <td class="ins0-move">SWP R,PTR</td>
          <td class="ins0-move">SWP R,*PTR</td>
          <td class="ins0-move">SWP R,OFS</td>
          <td class="ins0-move">SWP R,IX</td>
          <td class="ins0-move">SWP R,IS</td>
          <td class="ins0-move">SWP R,CTR</td>
          <td class="ins0-move">SWP R,CS</td>
          <td class="ins0-move">SWP R,*SP[U8]</td>
          <td class="ins0-move">SWP R,M</td>
          <td class="ins0-other">NOP</td>
          <td class="ins0-stack">PSH R0</td>
          <td class="ins0-stack">PSH R1</td>
          <td class="ins0-stack">PSH R2</td>
          <td class="ins0-stack">PSH R3</td>
          <td class="ins0-stack">PSH PTR0</td>
        </tr>
        <tr>
          <th>7</th>
          <td class="ins0-stack">PSH OFS0</td>
          <td class="ins0-stack">PSH IX0</td>
          <td class="ins0-stack">PSH IS0</td>
          <td class="ins0-stack">PSH CTR0</td>
          <td class="ins0-stack">PSH CS0</td>
          <td class="ins0-stack">PSH PTR1</td>
          <td class="ins0-stack">PSH OFS1</td>
          <td class="ins0-stack">PSH IX1</td>
          <td class="ins0-stack">PSH IS1</td>
          <td class="ins0-stack">PSH CTR1</td>
          <td class="ins0-stack">PSH CS1</td>
          <td class="ins0-stack">PSH ST</td>
          <td class="ins0-stack">PUL R0</td>
          <td class="ins0-stack">PUL R1</td>
          <td class="ins0-stack">PUL R2</td>
          <td class="ins0-stack">PUL R3</td>
        </tr>
        <tr>
          <th>8</th>
          <td class="ins0-stack">PUL PTR0</td>
          <td class="ins0-stack">PUL OFS0</td>
          <td class="ins0-stack">PUL IX0</td>
          <td class="ins0-stack">PUL IS0</td>
          <td class="ins0-stack">PUL CTR0</td>
          <td class="ins0-stack">PUL CS0</td>
          <td class="ins0-stack">PUL PTR1</td>
          <td class="ins0-stack">PUL OFS1</td>
          <td class="ins0-stack">PUL IX1</td>
          <td class="ins0-stack">PUL IS1</td>
          <td class="ins0-stack">PUL CTR1</td>
          <td class="ins0-stack">PUL CS1</td>
          <td class="ins0-stack">PUL ST</td>
          <td class="ins0-stack">SSP U8</td>
          <td class="ins0-status">CLC</td>
          <td class="ins0-status">SEC</td>
        </tr>
        <tr>
          <th>9</th>
          <td class="ins0-status">SAM0</td>
          <td class="ins0-status">SAM1</td>
          <td class="ins0-status">SAM2</td>
          <td class="ins0-status">SAM3</td>
          <td class="ins0-status">SAM4</td>
          <td class="ins0-status">SAM5</td>
          <td class="ins0-status">SAM6</td>
          <td class="ins0-status">SAM7</td>
          <td class="ins0-status">CLI</td>
          <td class="ins0-status">SEI</td>
          <td class="ins0-status">SR0</td>
          <td class="ins0-status">SR1</td>
          <td class="ins0-status">SR2</td>
          <td class="ins0-status">SR3</td>
          <td class="ins0-status">SPS0</td>
          <td class="ins0-status">SPS1</td>
        </tr>
        <tr>
          <th>A</th>
          <td class="ins0-status">SCS0</td>
          <td class="ins0-status">SCS1</td>
          <td class="ins0-status">SOS0</td>
          <td class="ins0-status">SOS1</td>
          <td class="ins0-status">SOS2</td>
          <td class="ins0-status">SOS3</td>
          <td class="ins0-status">SMM0</td>
          <td class="ins0-status">SMM1</td>
          <td class="ins0-status">SMM2</td>
          <td class="ins0-status">SMM3</td>
          <td class="ins0-unary">DEC R</td>
          <td class="ins0-unary">DEC *PTR</td>
          <td class="ins0-unary">INC R</td>
          <td class="ins0-unary">INC *PTR</td>
          <td class="ins0-unary">NEG R</td>
          <td class="ins0-unary">NEG *PTR</td>
        </tr>
        <tr>
          <th>B</th>
          <td class="ins0-unary">NG1 R</td>
          <td class="ins0-unary">NG1 *PTR</td>
          <td class="ins0-unary">NG1 IS</td>
          <td class="ins0-unary">NOT R</td>
          <td class="ins0-unary">NOT *PTR</td>
          <td class="ins0-unary">NXT OFS</td>
          <td class="ins0-unary">NXT IX</td>
          <td class="ins0-unary">NXT CTR</td>
          <td class="ins0-unary">ONE R</td>
          <td class="ins0-unary">ONE IS</td>
          <td class="ins0-unary">ONE CS</td>
          <td class="ins0-unary">SHAC R</td>
          <td class="ins0-unary">SHLC R</td>
          <td class="ins0-unary">SHRC R</td>
          <td class="ins0-unary">ZRO R</td>
          <td class="ins0-unary">ZRO OFS</td>
        </tr>
        <tr>
          <th>C</th>
          <td class="ins0-unary">ZRO IX</td>
          <td class="ins0-meta">LOOP CTR</td>
          <td class="ins0-meta">LOOP CTR,IS</td>
          <td class="ins0-meta">RSET0</td>
          <td class="ins0-meta">RSET1</td>
          <td class="ins0-meta">RSET2</td>
          <td class="ins0-meta">RSET3</td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
        <tr>
          <th>D</th>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
        <tr>
          <th>E</th>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
        <tr>
          <th>F</th>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
      </tbody>
    </table>
  </body>
</html>
