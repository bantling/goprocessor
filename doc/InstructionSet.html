<!DOCTYPE html>
<!--
   Copyright 2015 Greg Hall

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   $Id: InstructionSet.html 5631 2017-02-05 02:30:40Z  $
-->
<html>
  <head>
    <title>Instruction Set</title>
    <style type="text/css">  
      /* FF loads whatever it can first, in the order provided. List ttf first */
      @font-face {
        font-family: "Roboto Mono";
        src: url("roboto-mono.eot");
        src: url("roboto-mono.eot?#iefix") format("embedded-opentype"),
             url("roboto-mono.woff2") format("woff2"),
             url("roboto-mono.woff") format("woff"),
             url("roboto-mono.ttf") format("truetype"),
             url("roboto-mono.svg#webfont") format("svg");
      }
    
      /* Clear spacings */
      * {
        margin: 0;
        padding: 0;
        border: none;
      }
      
      /* Set some defaults */
      body {
        margin: 5px;
        font-family: "Roboto Mono", monospace;
        font-size: 9pt;
      }
      
      /* Every sibling except the first */
      * + * {
        margin-top: 10px;
      }
      
      /* Some browsers apply * + * to <br> tags, some don't */
      br {
        margin: 0;
      }
      
      h1 {
        font-size: 1.4em;
        font-weight: bold;
      }
      
      h2 {
        font-size: 1.2em;
        font-weight: bold;
      }
      
      ol > li {
        margin-left: 2em;
      }
      
      li + li, ol ul {
        margin-top: 0.25em;
      }
      
      ul > li {
        list-style: none;
        margin-left: 1em;
      }
      
      ul > li:before {
        position: relative;
        left: -1.25em;
        top: -0.25em;
        content: "\25CF";
        font-size: 0.75em;
      }
      
      table {
        border-collapse: collapse;
        font-size: 1em;
        font-weight: normal;
      }
      
      th, td {
        border: 1px solid black;
        padding: 2px 5px;
        white-space: nowrap;
      }
      
      th {
        font-weight: bold;
        text-align: center;
      }
      
      /* Table cells that show the header for a group of rows */
      td[colspan="4"] {
        font-weight: bold;
        padding: 10px 5px;
      }
      
      /* Colours for the opcodes legends */
      
      /*
       * Blue
       * #8DA9E2
       * #A9BFE9
       *
       * Green
       * #7DBD9D
       * #9DCEB6
       *
       * Orange
       * #CC7C2C
       * #EF7F0E
       *
       * Yellow
       * #BCAC34
       * #E2CB1B
       *
       * Red
       * #CC2C2F
       * #F40E12
       *
       * Grey
       * #AAAAAA
       */
      
      .ins0-binary {
        background-color: #8DA9E2;
      }
      
      .ins0-branch {
        background-color: #A9BFE9;
      }
      
      .ins0-move {
        background-color: #7DBD9D;
      }
      
      .ins0-other {
        background-color: #9DCEB6;
      }
      
      .ins0-ptr {
        background-color: #CC7C2C;
      }
      
      .ins0-stack {
        background-color: #EF7F0E;
      }
      
      .ins0-status {
        background-color: #BCAC34;
      }
      
      .ins0-unary {
        background-color: #E2CB1B;
      }
      
      /* Colour for the highlighting of opcodes */
      .hover {
        background-color: #EEEEEE;
      }
      
      /* Default count of opcodes, these are really just markers for JS */
      .count-ins0-binary::before {
        content: "0";
      }
      
      .count-ins0-branch::before {
        content: "0";
      }
      
      .count-ins0-move::before {
        content: "0";
      }
      
      .count-ins0-other::before {
        content: "0";
      }
      
      .count-ins0-ptr::before {
        content: "0";
      }
      
      .count-ins0-stack::before {
        content: "0";
      }
      
      .count-ins0-status::before {
        content: "0";
      }
      
      .count-ins0-unary::before {
        content: "0";
      }
    </style>
    
    <script type="text/javascript">
      /*
       * Store references to the inserted css rules in a global var. Some browsers decide that JS
       * code that responds to an event that accesses stylesheet rules may cause security problems.
       * By storing the styles we need in a global var, the event code can access them directly by
       * reference, bypassing the security mechanism.
       */
      var legendStyles = {
        hover: getCSSRules(".hover")
      };
    
      function doLoad(
      ) {
        // Get the style rule names for the opcodes from the names of the .count-insX-*::before rules, where X is 0 - 7
        for (var instrSet = 0; instrSet <= 7; instrSet++) {
          var colourRegex = new RegExp("^[.]count-(ins" + instrSet + "-[^:]*)::before$");
          var colourRules = getCSSRules(
            colourRegex
          );
          
          if (colourRules) {
            var colourNames = colourRules.map(
              function(rule) {
                return colourRegex.exec(rule.selectorText)[1];
              }
            );
        
            /*
             * Create a sorted array of {cssClass: k, count: c} pairs by counting elements in the
             * opcodes table. Sort in reverse from highest count to lowest count.
             */
            var opcodeCountsToClass = colourNames.reduce(
              function(opcodeCountsToClass, value) {
                opcodeCountsToClass.push(
                  {cssClass: value, count: document.querySelectorAll('#opcodes .' + value).length}
                );
                
                return opcodeCountsToClass;
              },
              []
            ).sort(
              function(a, b) {
                return b.count - a.count;
              }
            );
                    
            /*
             * Set the counts of opcodes by overriding the .count-X::before rules with new ones.
             * Re-order the colours, so that the colours are applied from most to least popular rule,
             * by overriding the .X rules that match the .count-X::before rules.
             *
             * The background-color is provided as an rgb(r,g,b) expression regardless of how it was
             * declared in the actual rule text. Some versions of IE ignore a
             * background-color: rgb(r,g,b) rule, instead expecting background: rgb(r,g,b).
             *
             * The simplest technically correct general solution is to convert the rgb expression into
             * a hex string definition.
             *
             * While we're at it, convert array of counts and names to a map of names to count
             */
            var colourNamesIndex = 0;
            var rgbRegex = /[(]\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)/;
            var opcodeCounts = {};
            opcodeCountsToClass.forEach(
              function(value) {
                // Insert count content
                insertCSSRule(".count-" + value.cssClass + "::before{content: '" + value.count + "';}");
                
                /*
                 * Insert new colour definition.
                 * The colour value we want to use is the next one from the colourNames array.
                 * The class name to define the colour for is the class of the current value.
                 */
                var rgbParts = rgbRegex.exec(
                  getCSSRules("." + colourNames[colourNamesIndex++]).style.backgroundColor
                );
                
                var hexString = "#" +
                  (rgbParts[1] < 16 ? "0" : "") + (+rgbParts[1]).toString(16) +
                  (rgbParts[2] < 16 ? "0" : "") + (+rgbParts[2]).toString(16) +
                  (rgbParts[3] < 16 ? "0" : "") + (+rgbParts[3]).toString(16);
                
                legendStyles[value.cssClass] =
                  insertCSSRule(
                    "." + value.cssClass + "{background-color: " + hexString + ";}"
                  );
                
                opcodeCounts[value.cssClass] = value.count;
              }
            );
    
            // Get the legend rows as presented        
            var originalLegend = document.querySelectorAll("#legend" + instrSet + " tbody")[0];
            
            // Get the legend rows in the order we want
            var opcodeRows = Array.prototype.slice.call(
              originalLegend.children,
              0
            ).reduce(
              // Split each row into two for sorting
              function(split, row) {
                split.push(Array.prototype.slice.call(row.children, 0, 3));
                split.push(Array.prototype.slice.call(row.children, 3));
                return split;
              },
              []
            ).sort(
              /*
               * Sort in order of decreasing opcode counts, then by ascending name.
               * Since the table is split into two columns, one row will have a blank entry if there is an odd number of
               * elements. The blank row will not have an entry in opcodeCounts, and opcodeCounts[...] will be undefined.
               * In such cases, convert undefined to 0.
               */
              function(a, b) {
                var compare = (opcodeCounts[b[2].className] || 0) - (opcodeCounts[a[2].className] || 0);
                return compare !== 0 ? compare : a[0].textContent.localeCompare(b[0].textContent);
              }
            ).reduce(
              // Join pairs of rows together
              function(join, row, index, sorted) {
                if (index < sorted.length / 2) {
                  join.push(row.concat(sorted[index + sorted.length / 2]));
                }
                return join;
              },
              []
            ).forEach(
              function(oldRow, index) {
                if (index === 0) {
                  while (originalLegend.hasChildNodes()) {
                    originalLegend.removeChild(originalLegend.lastChild);
                  }
                }
              
                var newRow = document.createElement("tr");
                
                oldRow.forEach(
                  function(col) {
                    newRow.appendChild(col);
                  }
                );
                
                originalLegend.appendChild(newRow);
              }
            );
            
            // Set up events for the legend
            var dom = document.querySelectorAll("#legend" + instrSet + " tbody td[class]");
            for (var i in dom) {
              dom[i].onmouseenter = doEnterExitLegend;
              dom[i].onmouseout   = doEnterExitLegend;
            }
          }
        }
      };
      
      var insertCSSRule = (function() {
        var lastStyleSheet = document.styleSheets[document.styleSheets.length - 1];
      
        return function(rule) {
          return lastStyleSheet.cssRules[
            lastStyleSheet.insertRule(
              rule,
              lastStyleSheet.cssRules.length
            )
          ];
        };
      })(); 
            
      function getCSSRules(ruleTest, deleteFlag) {
        var isRegex = ruleTest instanceof RegExp;
        if (! isRegex) {
          ruleTest = ruleTest.toLowerCase();
        }
        var result = false;
        
        if (document.styleSheets) {
          OUTER:
          for (var i = 0; i < document.styleSheets.length; i++) {
            var styleSheet = document.styleSheets[i];
            var cssRules = styleSheet.cssRules ? styleSheet.cssRules : styleSheet.rules;
            
            for (var j in cssRules) {
              var cssRule = cssRules[j];
              
              // Not all CSS Rule objects have a selectorText property
              if (
                cssRule &&
                cssRule.selectorText &&
                (
                  (isRegex && ruleTest.test(cssRule.selectorText.toLowerCase())) ||
                  ((! isRegex) && (cssRule.selectorText.toLowerCase() === ruleTest))
                )
              ) {
                if (deleteFlag === 'delete') {
                  if (styleSheet.deleteRule) {
                    styleSheet.deleteRule(j);
                  } else {
                    styleSheet.removeRule(j);
                  }
                  
                  result = true;
                  break OUTER;
                } else if (isRegex) {
                  if (result === false) {
                    result = [cssRule];
                  } else {
                    result.push(cssRule);
                  }
                } else {
                  result = cssRule;
                  break OUTER;
                }
              }
            }
          }
        }
        
        return result;
      };
      
      function doEnterExitLegend(
        e
      ) {
        var evt = e || window.event;
        var source = evt.target || evt.srcElement;
        
        var srcRule = legendStyles[source.className];
        var dstRule = legendStyles.hover;
        
        var tmp = srcRule.style.backgroundColor;
        srcRule.style.backgroundColor = dstRule.style.backgroundColor;
        dstRule.style.backgroundColor = tmp;
      };
    </script>
  </head>
  <body onload="doLoad();">
    <h1>Instruction Set</h1> 
    
    <h2>Registers</h2>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Purpose</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>R0 - R3</td>
          <td>64 bit signed General purpose registers</td>
        </tr>
        <tr>
          <td>PTR0 - PTR3</td>
          <td>32 bit unsigned Pointer registers</td>
        </tr>
        <tr>
          <td>OFS0 - OFS3</td>
          <td>16 bit unsigned Offset registers</td>
        </tr>
        <tr>
          <td>IX0 - IX3</td>
          <td>16 bit unsigned Index registers</td>
        </tr>
        <tr>
          <td>IS0 - IS3</td>
          <td>16 bit signed Index Step registers</td>
        </tr>
        <tr>
          <td>CTR0 - CTR3</td>
          <td>32 bit unsigned counter</td>
        </tr>
        <tr>
          <td>CS0 - CS3</td>
          <td>16 bit signed counter step</td>
        </tr>
        <tr>
          <td>TMR0 - TMR3</td>
          <td>
              32 bit unsigned Timer Interrupt with millisecond precision<br>
              Max value = 4,294,967.295 seconds = 71,582.788 minutes = 1193.05 hours = 49.71 days<br>
              A value of zero disables the timer
          </td>
        </tr>
        <tr>
          <td>TPTR0 - TPTR3</td>
          <td>32 bit unsigned Timer Pointer</td>
        </tr>
        <tr>
          <td>CP</td>
          <td>
            32 bit unsigned code pointer<br>
            The PTR, PC, SB, SL, and SP registers are all relative to CP<br>
            This effectively makes all reads and writes are relative to CP<br>
            This allows programs to be relocatable<br>
            Only the TPTR registers are absolute, so that they can trigger OS routines
          </td>
        </tr>
        <tr>
          <td>PC</td>
          <td>32 bit unsigned program counter</td>
        </tr>
        <tr>
          <td>SB</td>
          <td>32 bit unsigned stack base</td>
        </tr>
        <tr>
          <td>SL</td>
          <td>32 bit unsigned stack limit</td>
        </tr>
        <tr>
          <td>SP</td>
          <td>32 bit unsigned stack pointer</td>
        </tr>
        <tr>
          <td>ST</td>
          <td>16 bit status register, consists of CVZNAAAI WWRROODD:<br>
              Carry, oVerflow, Zero, Negative, Address mode, Interrupt Disable,<br>
              Write register set, Read register set, Operand mode, Decimal mode.
          </td>
        </tr>
      </tbody>
    </table>

    <h2>ST values</h2>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>C</td>
          <td>Carry</td>
        </tr>
        <tr>
          <td>V</td>
          <td>Overflow</td>
        </tr>
        <tr>
          <td>Z</td>
          <td>Zero</td>
        </tr>
        <tr>
          <td>N</td>
          <td>Negative</td>
        </tr>
        <tr>
          <td>AAA</td>
          <td>
            Address Mode (PTR = 100, OFS = 25, IX = 400, address 100 has 32 bit pointer to address 200)<br>
            000 = *PTR: PTR = 100<br>
            001 = *(PTR): PTR + OFS = 125<br>
            010 = *[PTR]: PTR + IX = 500<br>
            011 = *([PTR]): PTR + IX + OFS = 525<br>
            100 = **PTR: **PTR = 200<br>
            101 = **(PTR): **PTR + OFS = 200 + 25 = 225<br>
            110 = **[PTR]: **PTR + IX = 200 + 400 = 600<br>
            111 = **([PTR]): **PTR + IX + OFS = 200 + 400 + 25 = 625
          </td>
        </tr>
        <tr>
          <td>I</td>
          <td>Interrupt Disable</td>
        </tr>
        <tr>
          <td>WW</td>
          <td>
            Write Register, selects which general register to write to
          </td>
        </tr>
        <tr>
          <td>RR</td>
          <td>
            Read Register, selects which general register to read from
          </td>
        </tr>
        <tr>
          <td>OO</td>
          <td>
            Operand Mode<br>
            00: 8 bits<br>
            01: 16 bits<br>
            10: 32 bits<br>
            11: 64 bits
          </td>
        </tr>
        <tr>
          <td>DD</td>
          <td>
            Decimal Mode<br>
            00 = Integer<br>
            01 = Fractional<br>
            10 = Fixed Point<br>
            11 = Floating Point<br>
            <br>
            The decimal mode always affects the ADC, SBB, MUL, DIV, and CMP instructions<br>
            The floating point instructions (FS2F, FABS, FPOW, etc) always assume registers contain floating point values<br>
            The floating point mode is only required for ADC, SBB, MUL, DIV, and CMP<br>
            <br>
            Integer Mode:<br>
            For ADC, SBB, and MUL, Carry and overflow are (un)signed carry and overflow<br>
            For DIV, Carry is modulo, overflow has no meaning<br>
            The relevant CVZN flags are modified on each instruction<br>
            Highest bit is sign bit if using signed math<br>
            <br>
            Fractional Mode:<br>
            For ADC, SBB, and MUL, Carry and overflow are (un)signed carry and overflow<br>
            For DIV, Carry and overflow have no meaning<br>
            The relevant CVZN flags are modified on each instruction<br>
            A Register is split into numerator (upper half) and denominator (lower half)<br>
            Highest bit is sign bit if using signed math<br>
            Denominator is always unsigned<br>
            <br>
            Fixed Point Mode:<br>
            When operand size is 8 bits, 16 bits are used instead<br>
            Scaling factor and min/max range limited to decimal values:<br>
            16 bits: scaling factor = 10^-2, range = +/-99.99<br>
            32 bits: scaling factor = 10^-4, range = +/-99,999.9999<br>
            64 bits: scaling factor = 10^-8, range = +/-99,999,999,999.99999999<br>
            For ADC, SBB, and MUL, Carry has no meaning and overflow is overflow<br>
            For DIV, Carry is modulo, overflow has no meaning<br>
            The relevant CVZN flags are modified on each instruction<br>
            Highst bit is always sign bit, no unsigned math<br>
            <br>
            Floating Point Mode:<br>
            Carry = NaN<br>
            Overflow = Divide By Zero<br>
            ZN have usual meaning<br>
            The relevant CVZN flags are modified on each instruction<br>
            No unsigned math<br>
            Implemented as IEEE 754 Half Precision (16 bits), Single Precision (32 bits), or Double Precision (64 bits)<br>
          </td>
        </tr>
      </tbody>
    </table>
    
    <h2>Instructions</h2>
    <ul>
      <li>W = Selected Write Register</li>
      <li>R = Selected Read Register</li>
      <li>RW = Selected Read Register used for both reads and writes</li>
      <li>WIX = Selected Write Index Register</li>
      <li>WIS = Selected Write Index Step Register</li>
      <li>RIX = Selected Write Index Register</li>
      <li>RIS = Selected Read Index Step Register</li>
      <li>H = Highest bit, depends on operand size (bit 7, 15, 31, or 63)</li>
      <li>W' = Write Register value after the instruction has completed</li>
    </ul>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Description</th>
          <th>Modes</th>
          <th>Status flags</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td colspan="4">Binary (<span class="count-ins0-binary"></span> opcodes)</td>
        </tr>
        <tr>
          <td>ADC</td>
          <td>Add with carry</td>
          <td>
            W = W + R + C<br>
            C = 1 if (H(W) = 1 or H(R) = 1) and (H(W + R + C) = 0)<br>
            V = 1 if (H(W) = H(R)) and (H(W) != H(W + R + C))
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>AND</td>
          <td>Bitwise AND</td>
          <td>W = W & R</td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td>CMP</td>
          <td>Compare</td>
          <td>
            CMP Rx,Ry<br>
            C = 1 if Rx &gt;= Ry unsigned<br>
            V = 1 if Rx &gt;= Ry signed<br>
            Z = 1 if Rx = Ry<br>
            Unlike other binary instructions, CMP does not use W and R status flags.<br>
            Instead, there is a different CMP for each pair of Rx, Ry where x != y.
          </td>
          <td>CVZ----- --------</td>
        </tr>
        <tr>
          <td>OR</td>
          <td>Bitwise OR</td>
          <td>W = W | R</td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td>SBB</td>
          <td>Subtract with borrow</td>
          <td>
            W = W - R - C<br>
            C = 1 if (R + C) > W unsigned<br>
            V = 1 if (H(W) != H(R)) and (H(R) = H(W - R - C))<br>
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>SHL</td>
          <td>Shift bits left</td>
          <td>
            W = W &lt;&lt; R<br>
            C = 1 if any of the upper R bits of W are set
          </td>
          <td>C-ZN---- --------</td>
        </tr>
        <tr>
          <td>SHR</td>
          <td>Shift bits right</td>
          <td>
            W = W &gt;&gt; R<br>
            C = 1 if any of the lower R bits of W are set
          </td>
          <td>C-ZN---- --------</td>
        </tr>
        <tr>
          <td>SHA</td>
          <td>Shift bits right, arithmetic</td>
          <td>
            W = W &gt;&gt; R<br>
            Highest R bits of W' = H(W), causing the sign of W to remain the same<br>
            C = 1 if any of the lower R bits of W are set
          </td>
          <td>C-ZN---- --------</td>
        </tr>
        <tr>
          <td>XOR</td>
          <td>Bitwise XOR</td>
          <td>W = W ^ R</td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td colspan="4">Branch and Jump (<span class="count-ins0-branch"></span> opcodes)</td>
        </tr>
        <tr>
          <td>BCC (BLTU, BNANC)</td>
          <td>Branch on carry clear (Rx &lt; Ry unsigned, FP result is not NaN)</td>
          <td>
            PC = PC + O if C = 0
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BCS (BGEU, BNANS)</td>
          <td>Branch on carry set (Rx &gt;= Ry unsigned, FP result is NaN)</td>
          <td>
            PC = PC + O if C = 1
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BEQ</td>
          <td>Branch on equal to zero (Rx = Ry)</td>
          <td>
            PC = PC + O if Z = 1
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BMI</td>
          <td>Branch on negative</td>
          <td>
            PC = PC + O if N = 1
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BNE</td>
          <td>Branch on not equal to zero (Rx != Ry)</td>
          <td>
            PC = PC + O if Z = 0
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BPL</td>
          <td>Branch on positive</td>
          <td>
            PC = PC + O if N = 0
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BVC (BLTS, BDZC)</td>
          <td>Branch on overflow clear (Rx &lt; Ry signed, Divide by zero clear)</td>
          <td>
            PC = PC + O if V = 0
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BVS (BGES, BDZS)</td>
          <td>Branch on overflow set (Rx &gt;= Ry signed, Divide by zero set)</td>
          <td>
            PC = PC + O if V = 1
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>JMA</td>
          <td>Jump to an absolute unsigned address</td>
          <td>
            PC = W; or PC = O
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>JMCP</td>
          <td>Jump to an unsigned address relative to CP</td>
          <td>
            PC = CP + W; or PC = CP + O
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>JMP</td>
          <td>Jump to relative signed address</td>
          <td>
            PC = PC + W; or PC = PC + O
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>JSA</td>
          <td>Jump to subroutine at an absolute unsigned address</td>
          <td>
            Push PC<br>
            PC = W; or PC = O
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>JSCP</td>
          <td>Jump to subroutine at an unsigned address relative to CP</td>
          <td>
            Push PC<br>
            PC = CP + W; or PC = CP + O
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>JSR</td>
          <td>Jump to subroutine at a relative signed address</td>
          <td>
            Push PC<br>
            PC = PC + W; or PC = PC + O
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>RTI</td>
          <td>Return from interrupt</td>
          <td>
            Pull R0<br>
            Pull R1<br>
            Pull R2<br>
            Pull R3<br>
            Pull PTR0<br>
            Pull PTR1<br>
            Pull PTR2<br>
            Pull PTR3<br>
            Pull OFS0<br>
            Pull OFS1<br>
            Pull OFS2<br>
            Pull OFS3<br>
            Pull IX0<br>
            Pull IX1<br>
            Pull IX2<br>
            Pull IX3<br>
            Pull IS0<br>
            Pull IS1<br>
            Pull IS2<br>
            Pull IS3<br>
            Pull CTR0<br>
            Pull CTR1<br>
            Pull CTR2<br>
            Pull CTR3<br>
            Pull CS0<br>
            Pull CS1<br>
            Pull CS2<br>
            Pull CS3<br>
            Pull CP<br>
            Pull PC<br>
            Pull SB<br>
            Pull SL<br>
            Pull SP<br>
            Pull ST<br>
            A hardware error occurs if the stack underflows
          </td>
          <td>CVZNAAAI WWRROODD</td>
        </tr>
        <tr>
          <td>RTS</td>
          <td>Return from subroutine</td>
          <td>
            Pull PC; or SP = SP + unsigned 8-bit O, Pull PC<br>
            A hardware error occurs if the stack underflows
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td colspan="4">Move and swap (<span class="count-ins0-move"></span> opcodes)</td>
        </tr>
        <tr>
          <td>MOV</td>
          <td>Move data</td>
          <td>
            Set up register values by copying same numbered<br>
            registers values to/from R0 to R3:<br>
            MOV RW,PTR<br>
            MOV RW,OFS<br>
            MOV RW,IX<br>
            MOV RW,IS<br>
            MOV RW,CTR<br>
            MOV RW,CS<br>
            MOV RW,TMR<br>
            MOV RW,TPTR<br>
            MOV PTR,RW<br>
            MOV OFS,RW<br>
            MOV IX,RW<br>
            MOV IS,RW<br>
            MOV CTR,RW<br>
            MOV CS,RW<br>
            MOV TMR,RW<br>
            MOV TPTR,RW<br>
            SWP RW,PTR<br>
            SWP RW,OFS<br>
            SWP RW,IX<br>
            SWP RW,IS<br>
            SWP RW,CTR<br>
            SWP RW,CS<br>
            SWP RW,TMR<br>
            SWP RW,TPTR<br>
            <br>
            Set up register values by copying register values to/from R0:<br>
            MOV R0,CP<br>
            MOV R0,SB<br>
            MOV R0,SL<br>
            MOV R0,SP<br>
            MOV R0,ST<br>
            MOV CP,R0<br>
            MOV SB,R0<br>
            MOV SL,R0<br>
            MOV SP,R0<br>
            MOV ST,R0<br>
            <br>
            Copy memory from same numbered<br>
            pointers to/from R0 to R3 with current addressing mode:<br>
            MOV RW,*PTR<br>
            MOV *PTR,RW<br>
            SWP RW,*PTR<br>
            <br>
            Move values between registers Rx and Ry, where x != y:<br>
            MOV Rx, Ry<br>
            SWP Rx, Ry
            <br>
            Move values between register and stack allocated space,<br>
            The operand is a hard-coded 16-bit offset<br>
            MOV RW,*SP[O]<br>
            MOV *SP[O],RW<br>
            SWP RW,*SP[O]<br>
          </td>
          <td>
            --ZN---- --------<br>
            (MOV only)<br>
            (MOV ST,R0 affects all flags)
          </td>
        </tr>
        <tr>
          <td colspan="4">Other (<span class="count-ins0-other"></span> opcodes)</td>
        </tr>
        <tr>
          <td>NOP</td>
          <td>No operation</td>
          <td>Waste a CPU cycle</td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td colspan="4">Stack (<span class="count-ins0-stack"></span> opcodes)</td>
        </tr>
        <tr>
          <td>PSH</td>
          <td>Push on the stack</td>
          <td>
            If SP - register size &lt; SB execute *FFFFFFF8 interrupt with R0 = 0, R1 = 1 (SP overflow)<br>
            *SP = R<br>
            SP = SP - register size<br>
            Bytes are written so that highest byte is earliest memory address<br>
            <br>
            PSH R0<br>
            PSH R1<br>
            PSH R2<br>
            PSH R3<br>
            PSH PTR0<br>
            PSH PTR1<br>
            PSH PTR2<br>
            PSH PTR3<br>
            PSH OFS0<br>
            PSH OFS1<br>
            PSH OFS2<br>
            PSH OFS3<br>
            PSH IX0<br>
            PSH IX1<br>
            PSH IX2<br>
            PSH IX3<br>
            PSH IS0<br>
            PSH IS1<br>
            PSH IS2<br>
            PSH IS3<br>
            PSH CTR0<br>
            PSH CTR1<br>
            PSH CTR2<br>
            PSH CTR3<br>
            PSH CS0<br>
            PSH CS1<br>
            PSH CS2<br>
            PSH CS3<br>
            PSH ST<br>
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>PUL</td>
          <td>Pull off the stack</td>
          <td>
            If SP + register size &gt; SL execute *FFFFFFF8 interrupt with R0 = 0, R1 = 2 (SP underflow)<br>
            SP = SP + register size<br>
            R = *SP<br>
            <br>
            PUL R0<br>
            PUL R1<br>
            PUL R2<br>
            PUL R3<br>
            PUL PTR0<br>
            PUL PTR1<br>
            PUL PTR2<br>
            PUL PTR3<br>
            PUL OFS0<br>
            PUL OFS1<br>
            PUL OFS2<br>
            PUL OFS3<br>
            PUL IX0<br>
            PUL IX1<br>
            PUL IX2<br>
            PUL IX3<br>
            PUL IS0<br>
            PUL IS1<br>
            PUL IS2<br>
            PUL IS3<br>
            PUL CTR0<br>
            PUL CTR1<br>
            PUL CTR2<br>
            PUL CTR3<br>
            PUL CS0<br>
            PUL CS1<br>
            PUL CS2<br>
            PUL CS3<br>
            PUL ST<br>
          </td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td>SSP</td>
          <td>Subtract from stack pointer</td>
          <td>
            If SP - O &lt; SB execute *FFFFFFF8 interrupt with R0 = 0, R1 = 1 (SP overflow)<br>
            SP = SP - O<br>
            Operand size determined by instruction
          </td>
          <td>--------- --------</td>
        </tr>
        <tr>
          <td colspan="4">Status (<span class="count-ins0-status"></span> opcodes)</td>
        </tr>
        <tr>
          <td>CLC (CLNAN)</td>
          <td>Clear carry flag (Clear NaN)</td>
          <td>Set C = 0</td>
          <td>C------- --------</td>
        </tr>
        <tr>
          <td>CLI</td>
          <td>Clear hardware interrupt disable flag</td>
          <td>Set I = 0</td>
          <td>-------I --------</td>
        </tr>
        <tr>
          <td>SEC (SENAN)</td>
          <td>Set carry flag (Set NaN)</td>
          <td>Set C = 1</td>
          <td>C------- --------</td>
        </tr>
        <tr>
          <td>SEI</td>
          <td>Set hardware interrupt disable flag</td>
          <td>Set I = 1</td>
          <td>-------I --------</td>
        </tr>
        <tr>
          <td colspan="4">Unary (<span class="count-ins0-unary"></span> opcodes)</td>
        </tr>
        <tr>
          <td>DEC</td>
          <td>Decrement</td>
          <td>
            W = W - 1<br>
            C = 1 if (H(W) = 0) and (H(W') = 1)<br>
            V = 1 if (H(W) = 1) and (H(W') = 0)
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>INC</td>
          <td>Increment</td>
          <td>
            W = W + 1<br>
            C = 1 if (H(W) = 1) and (H(W') = 0)<br>
            V = 1 if (H(W) = 0) and (H(W') = 1)<br>
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>NEG</td>
          <td>Negate</td>
          <td>W = -W</td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td>NG1</td>
          <td>Set to -1</td>
          <td>
            W = -1<br>
            WIS = -1<br>
            RIS = -1<br>
            CS0 = -1<br>
            CS1 = -1<br>
            CS2 = -1<br>
            CS3 = -1
          </td>
          <td>--ZN----- --------</td>
        </tr>
        <tr>
          <td>NOT</td>
          <td>Bitwise NOT</td>
          <td>W = ~W</td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td>NXT</td>
          <td>Add step to register</td>
          <td>
            WIX = WIX + WIS<br>
            RIX = RIX + RIS<br>
            CTR0 = CTR0 + CS0<br>
            CTR1 = CTR1 + CS1<br>
            CTR2 = CTR2 + CS2<br>
            CTR3 = CTR3 + CS3<br>
            CVZN are set the same as for ADC
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>ONE</td>
          <td>Set to 1</td>
          <td>
            W = 1<br>
            WIX = 1<br>
            WIS = 1<br>
            RIX = 1<br>
            RIS = 1<br>
            CTR0 = 1<br>
            CS0 = 1<br>
            CTR1 = 1<br>
            CS1 = 1<br>
            CTR2 = 1<br>
            CS2 = 1<br>
            CTR3 = 1<br>
            CS3 = 1
          </td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td>SHLC</td>
          <td>Shift left with carry</td>
          <td>
            W = W &lt;&lt; 1<br>
            BIT0(W) = C<br>
            C = H(W)
          </td>
          <td>C-ZN--- --------</td>
        </tr>
        <tr>
          <td>SHRC</td>
          <td>Shift right with carry</td>
          <td>
            W = W &gt;&gt; 1<br>
            H(W) = C<br>
            C = BIT0(W)
          </td>
          <td>C-ZN--- --------</td>
        </tr>
        <tr>
          <td>SHAC</td>
          <td>Arithmetic shift right with carry</td>
          <td>
            W = W &gt;&gt; 1<br>
            H(W') = H(W)<br>
            C = BIT0(W)
          </td>
          <td>C-ZN--- --------</td>
        </tr>
        <tr>
          <td>ZRO</td>
          <td>Set to 0</td>
          <td>
            W = 0<br>
            WIX = 0<br>
            WIS = 0<br>
            RIX = 0<br>
            RIS = 0<br>
            CTR0 = 0<br>
            CS0 = 0<br>
            CTR1 = 0<br>
            CS1 = 0<br>
            CTR2 = 0<br>
            CS2 = 0<br>
            CTR3 = 0<br>
            CS3 = 0<br>
          </td>
          <td>--ZN---- --------</td>
        </tr>
      </tbody>
    </table>
    
    <h2>Branches and Jumps</h2>
    <p>
      All relative branches and jumps are relative to the address of the first byte of the next instruction.
      Branches use 8-bit operands, while jumps use 16-bit operands.
      Relative to the first byte of the branch itself, the 8-bit operand allows a jump in the range of [-126, 129],
      while a 16-bit operand allows a jump in the range of [-32765, 32770].
    </p>
    <p>
      JMCP/JSCP Allow jumps with a 32-bit unsigned address relative to the CP to jump anywhere within the current program.
    </p>
    <p>
      JMA/JSA Allow jumps with an absolute 32-bit usigned address to any code in the system, to allow for kernel jump tables.
    </p>
    <h2>Interrupts</h2>
    <ul>
      <li>Interrupts can only occur by hardware, there is no instruction to invoke an interrupt.</li>
      <li>The single non-maskable interrupt cannot be prevented from executing by the interrupt Disable flag.</li>
      <li>Maskable interrupts can only occur when the Interrupt Disabled flag is clear. Any routine should set this flag
        at the start of a critical section, and clear it at the end, whether the routine is a main program or an
        interrupt routine.
      </li>
      <li>An interrupt can only occur after the current instruction has completed, and pushes the address of the
        following instruction.
      </li>
      <li>Each interrupt pointer address represents a unique kind of interrupt. Once an interrupt of a given kind is
        generated, no more interrupts of that kind can be generated until the interrupt routine has completed with an
        RTI.
      </li>
      <li>If multiple interrupts occur during the same instruction execution, one interrupt is chosen by priority.</li>
      <li>An interrupt routine can be interrupted during a non-critical section by another kind of interrupt of higher
        priority, but it cannot be interrupted by another kind of interrupt of lower priority.
      </li>
      <li>Interrupts push the PC and ST registers in that order.</li>
      <li>Interrupts must end with an RTI instruction to signal that the interrupt has completed handling. RTI pulls the
        ST and PC registers in that order.
      </li>
      <li>Interrupt routines should only use branches and absolute jumps/jsrs, since relative jumps/jsrs are relative to
        the CP register, which is not pushed.
      </li>
      <li>It is up to the interrupt routine to preserve any other registers it modifies. Since a given kind of
        interrupt cannot be interrupted by the same kind of interrupt before completion, a given kind of interrupt may
        use the stack or a reserved memory area dedicated to that specific kind of interrupt to preserve registers
        and/or hold intermediate values.
      </li>
      <li>The following implications occur as a result of the above statements:
        <ol>
          <li>Interrupt disable flag handling
            <ul>
              <li>Interrupts necessarily push ST with interrupt disable clear</li>
              <li>Interrupts necessarily restore ST with interrupt disable flag clear</li>
              <li>Routines do not have to explicitly clear interrupt disable flag before returning</li>
            </ul>
          </li>
          <li>Stack handling</li>
            <ul>
              <li>Clearing interrupt disable immediately before returning provides an opportunity to interrupt the
                current routine just before returning and executoing another interrupt, increasing the size of the
                stack.
              </li>
              <li>Purposely not clearing the interrupt disable flag in the above situation prevents another interrupt
                from executing until after the registers are pulled from the stack for the current one, reducing stack
                size.
              </li>
            </ul>
          </li>
          <li>Main execution and multiple interrupts
            <ul>
              <li>If a series of sequential interrupts occur where the routines clear the interrupt disable before
                returning, the interrupts are nested
              </li>
              <li>If a series of sequential interrupts occur where the routines do not clear the interrupt disable flag
                before returning, the interrupts are chained - as soon as one finishes the next begins.
              </li>
              <li>In both cases, the routine being interrupted cannot proceed to execute a single instruction until all
                other interrupts have been handled - this is true whether the routine being interrupted is itself an
                interrupt routine or a main program.
              </li>
              <li>If one or more lower priority interrupts occur during the execution of a higher priority interrupt,
                none of the lower priority interrupts occur until the higher priority routine has completed with an RTI.
              </li> 
            </ul>
          </li>
          <li>Time critical interrupts
            <ul>
              <li>A time critical interrupt can begin by setting the interrupt Disable flag, and end with an RTI where
                there is no explicit clearing of the interrupt Disable flag.</li>
              <li>Since the first instruction sets interrupt Disable, and the entire routine is a critical section,
                there is no opportunity for another interrupt to occur, even one of higher priority.</li>
              <li>Technically, there should be no higher priority interrupts.</li>
            </ul>
          </li>
        </ol>
      </li>
    </ul>
    
    <h2>General Information</h2>
    <ol>
      <li>The processor is little endian - the highest byte is stored first, the lowest byte last</li>
      <li>8 24-bit interrupt pointers are defined, called INT 0 thru INT 7<br>
        INT 7 = non-maskable interrupt pointer, called by hardware reset and hardware errors
      </li>
      <li>Interrupts that provide a single byte of data to the routine can simply use the byte following the pointer.</li>
      <li>On a reset or hardware error, the byte following the INT 7 interrupt pointer has the following values:
        <ul>
          <li>On reset bit 0 = 0</li>
          <li>On hardware errors, bit 0 = 1
            <ul>
              <li>Stack overflow sets bit 1 = 0</li>
              <li>Stack underflow sets bit 1 = 1</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>The stack is 64k in size, and can point to any address.</li>
      <li>The stack base SB is the bottom, the top is SB + 0x00FFFF.</li>
      <li>If the SB is set to a value > 0xFF0000, then it is possible for the stack to wrap past 0xFFFFFF to 0x000000 if the
        SP has a large enough value. This can be prevented by setting an appropriate initial value for SP.</li>
      <li>When an address is pushed on the stack (eg, hardware interrupt, JSR, etc), it is pushed in little endian
        order, to make it easy to modify addresses on the stack.</li>
      <li>Since there is no software interrupt instruction, use JSX to call an address containing a JMX instruction that
        calls the actual routine at an OS defined address. Such a jump table provides well-known addresses for users to
        call OS routines, while allowing the OS routines to be moved around as they are updated.
      </li>
    </ol>
    
    <h2>Startup information</h2>
    <ul>
      <li>Registers have undefined values on initial hardware reset. They are undefined on startup simply because the
        user can cause a reset at anytime after startup, in which case the registers will hold whatever values the
        current routine being interrupted happens to be using.
      </li>
      <li>Hardware errors should be handled by killing the current program. In a simple system designed to only run one
        program at a time, hardware errors can simply do the same thing as a reset.
      </li>
      <li>A simple layout is to have OS code, data, jump table, and pointers fit into the last 64k segment:
        <ul>
          <li>FF0000 - FFBFFF: 48KB code</li>
          <li>FFC000 - FFDFFF: 8KB data</li>
          <li>FFE000 - FFFBFF: 7KB stack space</li>
          <li>FFFC00 - FFFFDF: 992 bytes for 248 JMX instructions for OS jump table, aligned on 4-byte boundaries
          <li>FFFFE0 - FFFFFF: 32 bytes for 8 24-bit interrupt pointers, aligned on 4-byte boundaries</li>
        </ul>
      </li>
      <li>Example of CPU executing non-maskable interrupt (INT 7 at FFFFFC - FFFFFE) at startup or any other time, that
        handles resets and hardware errors in the same way:
        <ul>
          <li>FFFFFC = 24-bit address FF0000, so that execution starts at the beginning of the last 64k segment</li>
          <li>Handler at FF0000 just sets up the stack location with values for ST and PC on it, then execute RTI to
             call reset routine:
<pre>
FF0000: MOV EX, FFE000      ;SB = FFE000
FF0004: MOV SB, EX
FF0005: MOV W0, 1BFB        ;SP = 1BFB, FFE000 + 1BFB = FFFBFB, as if 4 bytes have been pushed on stack
FF0008: MOV SP, W0
FF0009: MOV $FFFBFC, 0      ;FFFBFC = ST on stack = 0
FF000D: MOV $FFFBFD, FF0012 ;FFFBFD = PC on stack = FF0012
FF0011: RTI
</pre>
          <li>Reset routine should initialize to known conditions and execute some initial program:
<pre>
FF0012: MOV R0, 1      ;CS, IS = 1 
FF0014: SWP R0, CS
FF0015: MOV R0, 1
FF0017: SWP R0, IS
FF0018: MOV R0, 0      ;R0, R1, R23, R3, CX, IX = 0
FF001A: MOV R1, R0
FF001B: MOV R2, R0
FF001C: MOV R3, R0
FF001D: ZRO CX
FF001E: ZRO IX
FF001F: MOV EX, FF0000 ;CP = FF0000 
FF0023: MOV CP, EX
FF0024: MOV EX, FFC000 ;DP = FFC000
FF0028: MOV DP, EX
FF0029: MOV EX, FFE000 ;SB = FFE000
FF002D: MOV SB, EX
FF002E: MOV W0, 1BFF   ;SP = 1BFF, FFE000 + 1BFF = FFFBFF, as if 0 bytes have been pushed on stack
FF0031: MOV SP, W0
FF0032: Set up initial program
</pre>
          </li>
          <li>Note that the kernel jump table could contain an entry that points to FF0012 to allow programs to call the
            reset function if necessary.
          </li>
        </ul> 
      </li>
    </ul>
    
    <h2>Opcodes</h2>
    
    <p>Legend</p>
    <p>Note: roll mouse over the colours in the legend to highlight the instructions in the table.</p>
    <table id="legend0">
      <thead>
        <tr>
          <th>Instruction Group</th>
          <th>Opcodes</th>
          <th>Colour</th>
          <th>Instruction Group</th>
          <th>Opcodes</th>
          <th>Colour</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Binary</td>
          <td><span class="count-ins0-binary"></span></td>
          <td class="ins0-binary"></td>
          
          <td>Branch and Jump</td>
          <td><span class="count-ins0-branch"></span></td>
          <td class="ins0-branch"></td>
        </tr>
        <tr>
          <td>Move and swap</td>
          <td><span class="count-ins0-move"></span></td>
          <td class="ins0-move"></td>
          
          <td>Other</td>
          <td><span class="count-ins0-other"></span></td>
          <td class="ins0-other"></td>
        </tr>
        <tr>
          <td>Pointer</td>
          <td><span class="count-ins0-ptr"></span></td>
          <td class="ins0-ptr"></td>          
          
          <td>Stack</td>
          <td><span class="count-ins0-stack"></span></td>
          <td class="ins0-stack"></td>
        </tr>
        <tr>                    
          <td>Status</td>
          <td><span class="count-ins0-status"></span></td>
          <td class="ins0-status"></td>
          
          <td>Unary</td>
          <td><span class="count-ins0-unary"></span></td>
          <td class="ins0-unary"></td>
        </tr>
      </tbody>
    </table>
    
    <p>Opcodes</p>
    <table id="opcodes">
      <thead>
        <tr>
          <th></th>
          <th>0</th>
          <th>1</th>
          <th>2</th>
          <th>3</th>
          <th>4</th>
          <th>5</th>
          <th>6</th>
          <th>7</th>
          <th>8</th>
          <th>9</th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
          <th>D</th>
          <th>E</th>
          <th>F</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td class="ins0-move">MOV RW,PTR</td>
          <td class="ins0-move">MOV PTR,RW</td>
          <td class="ins0-move">SWP RW,PTR</td>
          <td class="ins0-move">MOV R0,CP</td>
          <td class="ins0-move">MOV CP,R0</td>
          <td class="ins0-move">SWP R0,R1</td>
          <td class="ins0-move">MOV RW,*PTR</td>
          <td class="ins0-stack">PSH R0</td>
          <td class="ins0-stack">PUL R0</td>
          <td class="ins0-stack">PSH IX0</td>
          <td class="ins0-stack">PUL IX0</td>
          <td class="ins0-stack">PSH CTR0</td>
          <td class="ins0-stack">PUL CTR0</td>
          <td class="ins0-stack">PSH OFS0</td>
          <td class="ins0-stack">PUL OFS0</td>
          <td class="ins0-branch">BCC</td>
        </tr>
        <tr>
          <th>1</th>
          <td class="ins0-move">MOV RW,OFS</td>
          <td class="ins0-move">MOV OFS,RW</td>
          <td class="ins0-move">SWP RW,OFS</td>
          <td class="ins0-move">MOV R0,SB</td>
          <td class="ins0-move">MOV SB,R0</td>
          <td class="ins0-move">SWP R0,R2</td>
          <td class="ins0-move">MOV *PTR,RW</td>
          <td class="ins0-stack">PSH R1</td>
          <td class="ins0-stack">PUL R1</td>
          <td class="ins0-stack">PSH IX1</td>
          <td class="ins0-stack">PUL IX1</td>
          <td class="ins0-stack">PSH CTR1</td>
          <td class="ins0-stack">PUL CTR1</td>
          <td class="ins0-stack">PSH OFS1</td>
          <td class="ins0-stack">PUL OFS1</td>
          <td class="ins0-branch">BCS</td>
        </tr>
        <tr>
          <th>2</th>
          <td class="ins0-move">MOV RW,IX</td>
          <td class="ins0-move">MOV IX,RW</td>
          <td class="ins0-move">SWP RW,IX</td>
          <td class="ins0-move">MOV R0,SL</td>
          <td class="ins0-move">MOV SL,R0</td>
          <td class="ins0-move">SWP R0,R3</td>
          <td class="ins0-move">SWP RW,*PTR</td>
          <td class="ins0-stack">PSH R2</td>
          <td class="ins0-stack">PUL R2</td>
          <td class="ins0-stack">PSH IX2</td>
          <td class="ins0-stack">PUL IX2</td>
          <td class="ins0-stack">PSH CTR2</td>
          <td class="ins0-stack">PUL CTR2</td>
          <td class="ins0-stack">PSH OFS2</td>
          <td class="ins0-stack">PUL OFS2</td>
          <td class="ins0-branch">BEQ</td>
        </tr>
        <tr>
          <th>3</th>
          <td class="ins0-move">MOV RW,IS</td>
          <td class="ins0-move">MOV IS,RW</td>
          <td class="ins0-move">SWP RW,IS</td>
          <td class="ins0-move">MOV R0,SP</td>
          <td class="ins0-move">MOV SP,R0</td>
          <td class="ins0-move">SWP R1,R2</td>
          <td class="ins0-move">SWP R2,R3</td>
          <td class="ins0-stack">PSH R3</td>
          <td class="ins0-stack">PUL R3</td>
          <td class="ins0-stack">PSH IX3</td>
          <td class="ins0-stack">PUL IX3</td>
          <td class="ins0-stack">PSH CTR3</td>
          <td class="ins0-stack">PUL CTR3</td>
          <td class="ins0-stack">PSH OFS3</td>
          <td class="ins0-stack">PUL OFS3</td>
          <td class="ins0-branch">BNE</td>
        </tr>
        <tr>
          <th>4</th>
          <td class="ins0-move">MOV RW,CTR</td>
          <td class="ins0-move">MOV CTR,RW</td>
          <td class="ins0-move">SWP RW,CTR</td>
          <td class="ins0-move">MOV R0,ST</td>
          <td class="ins0-move">MOV ST,R0</td>
          <td class="ins0-move">SWP R1,R3</td>
          <td class="ins0-stack">SSP O</td>
          <td class="ins0-stack">PSH PTR0</td>
          <td class="ins0-stack">PUL PTR0</td>
          <td class="ins0-stack">PSH IS0</td>
          <td class="ins0-stack">PUL IS0</td>
          <td class="ins0-stack">PSH CS0</td>
          <td class="ins0-stack">PUL CS0</td>
          <td class="ins0-stack">PSH ST</td>
          <td class="ins0-stack">PUL ST</td>
          <td class="ins0-branch">BMI</td>
        </tr>
        <tr>
          <th>5</th>
          <td class="ins0-move">MOV RW,CS</td>
          <td class="ins0-move">MOV CS,RW</td>
          <td class="ins0-move">SWP RW,CS</td>
          <td class="ins0-move">MOV R0,R1</td>
          <td class="ins0-move">MOV R1,R0</td>
          <td class="ins0-move">MOV R2,R0</td>
          <td class="ins0-move">MOV R3,R0</td>
          <td class="ins0-stack">PSH PTR1</td>
          <td class="ins0-stack">PUL PTR1</td>
          <td class="ins0-stack">PSH IS1</td>
          <td class="ins0-stack">PUL IS1</td>
          <td class="ins0-stack">PSH CS1</td>
          <td class="ins0-stack">PUL CS1</td>
          <td class="ins0-binary">SHL W,R</td>
          <td class="ins0-branch">JSA O</td>
          <td class="ins0-branch">BPL</td>
        </tr>
        <tr>
          <th>6</th>
          <td class="ins0-move">MOV RW,TMR</td>
          <td class="ins0-move">MOV TMR,RW</td>
          <td class="ins0-move">SWP RW,TMR</td>
          <td class="ins0-move">MOV R0,R2</td>
          <td class="ins0-move">MOV R1,R2</td>
          <td class="ins0-move">MOV R2,R1</td>
          <td class="ins0-move">MOV R3,R1</td>
          <td class="ins0-stack">PSH PTR2</td>
          <td class="ins0-stack">PUL PTR2</td>
          <td class="ins0-stack">PSH IS2</td>
          <td class="ins0-stack">PUL IS2</td>
          <td class="ins0-stack">PSH CS2</td>
          <td class="ins0-stack">PUL CS2</td>
          <td class="ins0-binary">SHR W,R</td>
          <td class="ins0-branch">JSCP W</td>
          <td class="ins0-branch">BVC</td>
        </tr>
        <tr>
          <th>7</th>
          <td class="ins0-move">MOV RW,TPTR</td>
          <td class="ins0-move">MOV TPTR,RW</td>
          <td class="ins0-move">SWP RW,TPTR</td>
          <td class="ins0-move">MOV R0,R3</td>
          <td class="ins0-move">MOV R1,R3</td>
          <td class="ins0-move">MOV R2,R3</td>
          <td class="ins0-move">MOV R3,R2</td>
          <td class="ins0-stack">PSH PTR3</td>
          <td class="ins0-stack">PUL PTR3</td>
          <td class="ins0-stack">PSH IS3</td>
          <td class="ins0-stack">PUL IS3</td>
          <td class="ins0-stack">PSH CS3</td>
          <td class="ins0-stack">PUL CS3</td>
          <td class="ins0-binary">SHA W,R</td>
          <td class="ins0-branch">JSCP O</td>
          <td class="ins0-branch">BVS</td>
        </tr>
        <tr>
          <th>8</th>
          <td class="ins0-move">MOV RW,*SP[O]</td>
          <td class="ins0-move">MOV *SP[O],RW</td>
          <td class="ins0-move">SWP RW,*SP[O]</td>
          <td class="ins0-binary">ADC W,R</td>
          <td class="ins0-binary">AND W,R</td>
          <td class="ins0-binary">CMP R0,R1</td>
          <td class="ins0-binary">CMP R0,R2</td>
          <td class="ins0-binary">CMP R0,R3</td>
          <td class="ins0-binary">CMP R1,R2</td>
          <td class="ins0-binary">CMP R1,R3</td>
          <td class="ins0-binary">CMP R2,R3</td>
          <td class="ins0-binary">OR W,R</td>
          <td class="ins0-binary">SBB W,R</td>
          <td class="ins0-binary">XOR W,R</td>
          <td class="ins0-branch">JSR W</td>
          <td class="ins0-branch">JMA W</td>
        </tr>
        <tr>
          <th>9</th>
          <td class="ins0-unary">DEC W</td>
          <td class="ins0-unary">INC W</td>
          <td class="ins0-unary">NEG W</td>
          <td class="ins0-unary">NG1 W</td>
          <td class="ins0-unary">NG1 WIS</td>
          <td class="ins0-unary">NG1 RIS</td>
          <td class="ins0-unary">NG1 CS0</td>
          <td class="ins0-unary">NG1 CS1</td>
          <td class="ins0-unary">NG1 CS2</td>
          <td class="ins0-unary">NG1 CS3</td>
          <td class="ins0-unary">NOT W</td>
          <td class="ins0-unary">NXT WIX</td>
          <td class="ins0-unary">NXT RIX</td>
          <td class="ins0-unary">NXT CTR0</td>
          <td class="ins0-branch">JSR O</td>
          <td class="ins0-branch">JMA O</td>
        </tr>
        <tr>
          <th>A</th>
          <td class="ins0-unary">NXT CTR1</td>
          <td class="ins0-unary">NXT CTR2</td>
          <td class="ins0-unary">NXT CTR3</td>
          <td class="ins0-unary">ONE W</td>
          <td class="ins0-unary">ONE WIX</td>
          <td class="ins0-unary">ONE WIS</td>
          <td class="ins0-unary">ONE RIX</td>
          <td class="ins0-unary">ONE RIS</td>
          <td class="ins0-unary">ONE CTR0</td>
          <td class="ins0-unary">ONE CS0</td>
          <td class="ins0-unary">ONE CTR1</td>
          <td class="ins0-unary">ONE CS1</td>
          <td class="ins0-unary">ONE CTR2</td>
          <td class="ins0-unary">ONE CS2</td>
          <td class="ins0-branch">RTI</td>
          <td class="ins0-branch">JMCP W</td>
        </tr>
        <tr>
          <th>B</th>
          <td class="ins0-unary">ONE CTR3</td>
          <td class="ins0-unary">ONE CS3</td>
          <td class="ins0-unary">SHLC W</td>
          <td class="ins0-unary">SHRC W</td>
          <td class="ins0-unary">SHAC W</td>
          <td class="ins0-unary">ZRO W</td>
          <td class="ins0-unary">ZRO WIX</td>
          <td class="ins0-unary">ZRO WIS</td>
          <td class="ins0-unary">ZRO RIX</td>
          <td class="ins0-unary">ZRO RIS</td>
          <td class="ins0-unary">ZRO CTR0</td>
          <td class="ins0-unary">ZRO CS0</td>
          <td class="ins0-unary">ZRO CTR1</td>
          <td class="ins0-unary">ZRO CS1</td>
          <td class="ins0-branch">RTS</td>
          <td class="ins0-branch">JMCP O</td>
        </tr>
        <tr>
          <th>C</th>
          <td class="ins0-unary">ZRO CTR2</td>
          <td class="ins0-unary">ZRO CS2</td>
          <td class="ins0-unary">ZRO CTR3</td>
          <td class="ins0-unary">ZRO CS2</td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-status">CLC</td>
          <td class="ins0-branch">JMP W</td>
        </tr>
        <tr>
          <th>D</th>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-status">SEC</td>
          <td class="ins0-branch">JMP O</td>
        </tr>
        <tr>
          <th>E</th>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-status">CLI</td>
          <td class="ins0-branch">JSA W</td>
        </tr>
        <tr>
          <th>F</th>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-status">SEI</td>
          <td class="ins0-other">NOP</td>
        </tr>
      </tbody>
    </table>
  </body>
</html>
