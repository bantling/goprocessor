<!DOCTYPE html>
<!--
   Copyright 2015 Greg Hall

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   $Id: InstructionSet.html 5631 2017-02-05 02:30:40Z  $
-->
<html>
  <head>
    <title>Instruction Set</title>
    <style type="text/css">  
      /* FF loads whatever it can first, in the order provided. List ttf first */
      @font-face {
        font-family: "Roboto Mono";
        src: url("roboto-mono.eot");
        src: url("roboto-mono.eot?#iefix") format("embedded-opentype"),
             url("roboto-mono.woff2") format("woff2"),
             url("roboto-mono.woff") format("woff"),
             url("roboto-mono.ttf") format("truetype"),
             url("roboto-mono.svg#webfont") format("svg");
      }
      
      /* Clear spacings */
      * {
        margin: 0;
        padding: 0;
        border: none;
      }
      
      /* Set some defaults */
      body {
        margin: 5px;
        font-family: "Roboto Mono", monospace;
        font-size: 9pt;
      }
      
      /* Every sibling except the first */
      * + * {
        margin-top: 10px;
      }
      
      /* Some browsers apply * + * to <br> tags, some don't */
      br {
        margin: 0;
      }
      
      h1 {
        font-size: 1.4em;
        font-weight: bold;
      }
      
      h2 {
        font-size: 1.2em;
        font-weight: bold;
      }
      
      ol > li {
        margin-left: 2em;
      }
      
      li + li, ol ul {
        margin-top: 0.25em;
      }
      
      ul > li {
        list-style: none;
        margin-left: 1em;
      }
      
      ul > li:before {
        position: relative;
        left: -1.25em;
        top: -0.25em;
        content: "\25CF";
        font-size: 0.75em;
      }
      
      table {
        border-collapse: collapse;
        font-size: 1em;
        font-weight: normal;
      }
      
      th, td {
        border: 1px solid black;
        padding: 2px 5px;
        white-space: nowrap;
      }
      
      th {
        font-weight: bold;
        text-align: center;
      }
      
      /* Table cells that show the header for a group of rows */
      td[colspan="4"] {
        font-weight: bold;
        padding: 10px 5px;
      }
      
      /* the pre class uses preformatted text */
      .pre td {
        white-space: pre;
      }
      
      /* Colours for the opcodes legends */
      
      /*
       * Blue
       * #8DA9E2
       * #A9BFE9
       *
       * Green
       * #7DBD9D
       * #9DCEB6
       *
       * Orange
       * #CC7C2C
       * #EF7F0E
       *
       * Yellow
       * #BCAC34
       * #E2CB1B
       *
       * Red
       * #CC2C2F
       * #F40E12
       *
       * Grey
       * #AAAAAA
       */
      
      .ins0-binary {
        background-color: #8DA9E2;
      }
      
      .ins0-branch {
        background-color: #A9BFE9;
      }
      
      .ins0-move {
        background-color: #7DBD9D;
      }
      
      .ins0-other {
        background-color: #9DCEB6;
      }
      
      .ins0-float {
        background-color: #CC7C2C;
      }
      
      .ins0-stack {
        background-color: #EF7F0E;
      }
      
      .ins0-status {
        background-color: #BCAC34;
      }
      
      .ins0-unary {
        background-color: #E2CB1B;
      }
      
      /* Colour for the highlighting of opcodes */
      .hover {
        background-color: #EEEEEE;
      }
      
      /* Default count of opcodes, these are really just markers for JS */
      .count-ins0-binary::before {
        content: "0";
      }
      
      .count-ins0-branch::before {
        content: "0";
      }
      
      .count-ins0-move::before {
        content: "0";
      }
      
      .count-ins0-other::before {
        content: "0";
      }
      
      .count-ins0-float::before {
        content: "0";
      }
      
      .count-ins0-stack::before {
        content: "0";
      }
      
      .count-ins0-status::before {
        content: "0";
      }
      
      .count-ins0-unary::before {
        content: "0";
      }
    </style>
    
    <script type="text/javascript">
      /*
       * Store references to the inserted css rules in a global var. Some browsers decide that JS
       * code that responds to an event that accesses stylesheet rules may cause security problems.
       * By storing the styles we need in a global var, the event code can access them directly by
       * reference, bypassing the security mechanism.
       */
      var legendStyles = {
        hover: getCSSRules(".hover")
      };
    
      function doLoad(
      ) {
        // Get the style rule names for the opcodes from the names of the .count-insX-*::before rules, where X is 0 - 7
        for (var instrSet = 0; instrSet <= 7; instrSet++) {
          var colourRegex = new RegExp("^[.]count-(ins" + instrSet + "-[^:]*)::before$");
          var colourRules = getCSSRules(
            colourRegex
          );
          
          if (colourRules) {
            var colourNames = colourRules.map(
              function(rule) {
                return colourRegex.exec(rule.selectorText)[1];
              }
            );
        
            /*
             * Create a sorted array of {cssClass: k, count: c} pairs by counting elements in the
             * opcodes table. Sort in reverse from highest count to lowest count.
             */
            var opcodeCountsToClass = colourNames.reduce(
              function(opcodeCountsToClass, value) {
                opcodeCountsToClass.push(
                  {cssClass: value, count: document.querySelectorAll('#opcodes .' + value).length}
                );
                
                return opcodeCountsToClass;
              },
              []
            ).sort(
              function(a, b) {
                return b.count - a.count;
              }
            );
                    
            /*
             * Set the counts of opcodes by overriding the .count-X::before rules with new ones.
             * Re-order the colours, so that the colours are applied from most to least popular rule,
             * by overriding the .X rules that match the .count-X::before rules.
             *
             * The background-color is provided as an rgb(r,g,b) expression regardless of how it was
             * declared in the actual rule text. Some versions of IE ignore a
             * background-color: rgb(r,g,b) rule, instead expecting background: rgb(r,g,b).
             *
             * The simplest technically correct general solution is to convert the rgb expression into
             * a hex string definition.
             *
             * While we're at it, convert array of counts and names to a map of names to count
             */
            var colourNamesIndex = 0;
            var rgbRegex = /[(]\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)/;
            var opcodeCounts = {};
            opcodeCountsToClass.forEach(
              function(value) {
                // Insert count content
                insertCSSRule(".count-" + value.cssClass + "::before{content: '" + value.count + "';}");
                
                /*
                 * Insert new colour definition.
                 * The colour value we want to use is the next one from the colourNames array.
                 * The class name to define the colour for is the class of the current value.
                 */
                var rgbParts = rgbRegex.exec(
                  getCSSRules("." + colourNames[colourNamesIndex++]).style.backgroundColor
                );
                
                var hexString = "#" +
                  (rgbParts[1] < 16 ? "0" : "") + (+rgbParts[1]).toString(16) +
                  (rgbParts[2] < 16 ? "0" : "") + (+rgbParts[2]).toString(16) +
                  (rgbParts[3] < 16 ? "0" : "") + (+rgbParts[3]).toString(16);
                
                legendStyles[value.cssClass] =
                  insertCSSRule(
                    "." + value.cssClass + "{background-color: " + hexString + ";}"
                  );
                
                opcodeCounts[value.cssClass] = value.count;
              }
            );
    
            // Get the legend rows as presented        
            var originalLegend = document.querySelectorAll("#legend" + instrSet + " tbody")[0];
            
            // Get the legend rows in the order we want
            var opcodeRows = Array.prototype.slice.call(
              originalLegend.children,
              0
            ).reduce(
              // Split each row into two for sorting
              function(split, row) {
                split.push(Array.prototype.slice.call(row.children, 0, 3));
                split.push(Array.prototype.slice.call(row.children, 3));
                return split;
              },
              []
            ).sort(
              /*
               * Sort in order of decreasing opcode counts, then by ascending name.
               * Since the table is split into two columns, one row will have a blank entry if there is an odd number of
               * elements. The blank row will not have an entry in opcodeCounts, and opcodeCounts[...] will be undefined.
               * In such cases, convert undefined to 0.
               */
              function(a, b) {
                var compare = (opcodeCounts[b[2].className] || 0) - (opcodeCounts[a[2].className] || 0);
                return compare !== 0 ? compare : a[0].textContent.localeCompare(b[0].textContent);
              }
            ).reduce(
              // Join pairs of rows together
              function(join, row, index, sorted) {
                if (index < sorted.length / 2) {
                  join.push(row.concat(sorted[index + sorted.length / 2]));
                }
                return join;
              },
              []
            ).forEach(
              function(oldRow, index) {
                if (index === 0) {
                  while (originalLegend.hasChildNodes()) {
                    originalLegend.removeChild(originalLegend.lastChild);
                  }
                }
              
                var newRow = document.createElement("tr");
                
                oldRow.forEach(
                  function(col) {
                    newRow.appendChild(col);
                  }
                );
                
                originalLegend.appendChild(newRow);
              }
            );
            
            // Set up events for the legend
            var dom = document.querySelectorAll("#legend" + instrSet + " tbody td[class]");
            for (var i in dom) {
              dom[i].onmouseenter = doEnterExitLegend;
              dom[i].onmouseout   = doEnterExitLegend;
            }
          }
        }
      };
      
      var insertCSSRule = (function() {
        var lastStyleSheet = document.styleSheets[document.styleSheets.length - 1];
      
        return function(rule) {
          return lastStyleSheet.cssRules[
            lastStyleSheet.insertRule(
              rule,
              lastStyleSheet.cssRules.length
            )
          ];
        };
      })(); 
            
      function getCSSRules(ruleTest, deleteFlag) {
        var isRegex = ruleTest instanceof RegExp;
        if (! isRegex) {
          ruleTest = ruleTest.toLowerCase();
        }
        var result = false;
        
        if (document.styleSheets) {
          OUTER:
          for (var i = 0; i < document.styleSheets.length; i++) {
            var styleSheet = document.styleSheets[i];
            var cssRules = styleSheet.cssRules ? styleSheet.cssRules : styleSheet.rules;
            
            for (var j in cssRules) {
              var cssRule = cssRules[j];
              
              // Not all CSS Rule objects have a selectorText property
              if (
                cssRule &&
                cssRule.selectorText &&
                (
                  (isRegex && ruleTest.test(cssRule.selectorText.toLowerCase())) ||
                  ((! isRegex) && (cssRule.selectorText.toLowerCase() === ruleTest))
                )
              ) {
                if (deleteFlag === 'delete') {
                  if (styleSheet.deleteRule) {
                    styleSheet.deleteRule(j);
                  } else {
                    styleSheet.removeRule(j);
                  }
                  
                  result = true;
                  break OUTER;
                } else if (isRegex) {
                  if (result === false) {
                    result = [cssRule];
                  } else {
                    result.push(cssRule);
                  }
                } else {
                  result = cssRule;
                  break OUTER;
                }
              }
            }
          }
        }
        
        return result;
      };
      
      function doEnterExitLegend(
        e
      ) {
        var evt = e || window.event;
        var source = evt.target || evt.srcElement;
        
        var srcRule = legendStyles[source.className];
        var dstRule = legendStyles.hover;
        
        var tmp = srcRule.style.backgroundColor;
        srcRule.style.backgroundColor = dstRule.style.backgroundColor;
        dstRule.style.backgroundColor = tmp;
      };
    </script>
  </head>
  <body onload="doLoad();">
    <h1>Instruction Set</h1>
    
    <h2>Example code</h2>
    <table>
      <thead>
        <tr>
          <th>Comment</th>
          <th>Code</th>
        </tr>
      </thead>
      <tbody class="pre">
        <tr>
          <td>Read/write single 8 bit value
</td>
          <td>  SEL   SET0      ; Select R0, PTR0, OFS0, IX0, IS0, CTR0, CS0 
  SIZE  8         ; Read/write 8 bits to memory
  LD    PTR, 0x100; Load pointer with address DP + 0x100
  RD    R,   *PTR ; Read derefd pointer into R (read address DP + 0x100)
  INC   R         ; R = R + 1
  WD    R,   *PTR ; Write R into derefd pointer (write address DP + 0x100)
</td>
        </tr>
        <tr>
          <td>Sum one dimensional array of 10 16-bit ints</td>
          <td>  SEL   SET0       ; Select R0, PTR0, OFS0, IX0, IS0, CTR0, CS0
  SIZE  16         ; Read/write 16 bits to memory
  LD    PTR, 0x100 ; Load pointer with address DP + 0x100
  LOOP  10         ; IX0 = 0, IS0 = 1, CTR0 = 10, CS0 = 1
  ZRO   R          ; R0 = 0
SUM:
  ADD   R,   *[PTR]; R0 = R0 + (DP + 0x100 + IX0) 
  NXT   IX         ; IX0 = IX0 + IS0 
  NXT   CTR        ; CTR0 = CTR0 - CS0
  BNE   SUM        ; LOOP again if CTR0 > 0
                   ; R contains sum of (DP + 0x100) thru (DP + 0x109)
</td>
        </tr>
        <tr>
          <td>Sum two dimensional array of 5 rows of 10 32-bit ints</td>
          <td>  SEL   SET0         ; Select R0, PTR0, OFS0, IX0, IS0, CTR0, CS0
  SIZE  32           ; Read/write 32 bits to memory
  LD    PTR, 0x100   ; Load pointer with address DP + 0x100
  LOOP  10, 40       ; IX0 = 0, IS0 = 40 (size of 1 row of 10 32-bit ints), CTR0 = 10, CS0 = 1
  ZRO   OFS          ; OFS = 0
  ZRO   R            ; R0 = 0
SUM:
  ADD   R,   *([PTR]); R0 = R0 + (DP + 0x100 + IX0 + OFS0)
  NXT   OFS          ; OFS0 = OFS0 + 4 (SIZE = 32)
  CMP   OFS, 40      ; Z = 1 if OFS == 40
  BNE   SUM          ; Loop until we've summed all 10 32-bit values in current row
  NXT   IX           ; IX0 = IX0 + IS0 (next row)
  ZRO   OFS          ; OFS0 = 0 
  NXT   CTR          ; CTR0 = CTR0 - CS0
  BNE   SUM          ; LOOP again if CTR0 > 0
                     ; R contains sum of (DP + 0x100) thru (DP + 0x1C8) 
</td>
        </tr>
        <tr>
          <td>Access an 8-bit field of an object</td>
          <td>  SEL   SET0       ; Select R0, PTR0, OFS0, IX0, IS0, CTR0, CS0 
  SIZE  8          ; Read/write 8 bits to memory
  LD    PTR, 0x100 ; Load pointer with address DP + 0x100
  LD    OFS, 0x10  ; Field offset
  RD    R,   *(PTR); Read derefd pointer into R (read address DP + 0x100 + 0x10)
  INC   R          ; R = R + 1
  WD    R,   *(PTR); Write R into derefd pointer (write address DP + 0x100 + 0x10)
          </td>
        </tr>
        <tr>
          <td>Execute a method for an object</td>
          <td>  SEL   SET0        ; Select R0, PTR0, OFS0, IX0, IS0, CTR0, CS0 
  SIZE  32          ; Read/write 32 bits to memory
  LD    PTR, 0x100  ; Load pointer with address DP + 0x100 (which points to class def at 0x200) 
  PSH   PTR         ; Push object address (DP + 0x100) on stack for value of "this"
  LD    OFS, 0x10   ; Field offset of method
  RD    R,   *(*PTR); Read method pointer into R (read address DP + 0x200 + 0x10, contains pointer to method at 0x300)
  JSR   R           ; Call method
  ...

0x300:
  PSH   ST          ; Push status register
  SEL   SET0        ; Select R0, PTR0, OFS0, IX0, IS0, CTR0, CS0
  PSH   OFS         ; Push OFS0
  PSH   R0          ; Push R0
                    ; Stack has 32-bit this ptr (0x100), 32-bit ptr of caller after JSR, 32-bit ST, 16-bit OFS, 32-bit R0
  SIZE  32          ; Read/write 32 bits to memory
  LD    PTR, *SP[14]; Add 14 bytes to SP to skip R0, OFS, ST and ptr to caller, read this ptr
  LD    OFS, 0x20   ; Field offset of this object
  RD    R,   *(PTR) ; R0 = 32 bits from (DP + 0x100 + 0x20)
  ...
  PUL OFS           ; PUL OFS
  PUL ST            ; PUL ST
  RTS               ; Return to caller 
          </td>
        </tr>
      </tbody>
    </table> 
    
    <h2>Registers</h2>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Purpose</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>R0 - R3</td>
          <td>
            64 bit (un)signed general purpose registers that work in two pairs: (R0, R1) and (R2, R3).<br>
            Instructions that require two of these registers will work with a pair,<br>
            where one register is referred to as the complement:<br>
            R0 complement = R1<br>
            R1 complement = R0<br>
            R2 complement = R3<br>
            R3 complement = R2<br>
            When a literal or memory operand is loaded into a register, and the current operand size<br>
            is less than 64 bits, the highest bit of the operand is copied into the upper bits to extend the sign.
          </td>
        </tr>
        <tr>
          <td>PTR0, PTR1</td>
          <td>32 bit unsigned pointer registers</td>
        </tr>
        <tr>
          <td>OFS0, OFS1</td>
          <td>16 bit unsigned offset registers</td>
        </tr>
        <tr>
          <td>IX0, IX1</td>
          <td>16 bit unsigned index registers</td>
        </tr>
        <tr>
          <td>IS0, IS1</td>
          <td>16 bit signed index step registers</td>
        </tr>
        <tr>
          <td>CTR0, CTR1</td>
          <td>32 bit unsigned counter registers that count backwards to 0</td>
        </tr>
        <tr>
          <td>CS0, CS1</td>
          <td>16 bit unsigned counter step registers</td>
        </tr>
        <tr>
          <td>PC</td>
          <td>32 bit unsigned program counter</td>
        </tr>
        <tr>
          <td>ST</td>
          <td>32 bit status register, consists of CVZNAAAI RRPTOOMM SSSSSSSS UUUUUUUU:<br>
              Carry, oVerflow, Zero, Negative, Address mode, Interrupt Disable<br>
              Register, Pointer register, counTer register, Operand size, Math mode<br>
              There are 8 bits reserved for system use, and 8 bits reserved for users.
          </td>
        </tr>
        <tr>
          <td>SB</td>
          <td>
            32 bit stack base register<br>
            Default location is FFFE0000 (second highest 64k)
          </td>
        </tr>
        <tr>
          <td>SP</td>
          <td>16 bit stack pointer register</td>
        </tr>
      </tbody>
    </table>

    <h2>ST values</h2>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>C</td>
          <td>Carry</td>
        </tr>
        <tr>
          <td>V</td>
          <td>Overflow</td>
        </tr>
        <tr>
          <td>Z</td>
          <td>Zero</td>
        </tr>
        <tr>
          <td>N</td>
          <td>Negative</td>
        </tr>
        <tr>
          <td>AAA</td>
          <td>
            Selected Address Mode (PTR = 100, OFS = 25, IX = 400, address 100 has pointer to address 200)<br>
            000 = *PTR = PTR = 100<br>
            001 = *(PTR) = PTR + OFS = 125<br>
            010 = *[PTR] = PTR + IX = 500<br>
            011 = *([PTR]) = PTR + IX + OFS = 525<br>
            100 = **PTR = *PTR = 200<br>
            101 = **(PTR): *PTR + OFS = 200 + 25 = 225<br>
            110 = **[PTR]: *PTR + IX = 200 + 400 = 600<br>
            111 = **([PTR]): *PTR + IX + OFS = 200 + 400 + 25 = 625
          </td>
        </tr>
        <tr>
          <td>I</td>
          <td>Interrupt Disable</td>
        </tr>
        <tr>
          <td>RR</td>
          <td>
            Selected general purpose register
          </td>
        </tr>
        <tr>
          <td>P</td>
          <td>
            Selected pointer register set (PTR, OFS, IX, IS)
          </td>
        </tr>
        <tr>
          <td>T</td>
          <td>
            Selected counter register set (CTR, CS)
          </td>
        </tr>
        <tr>
          <td>OO</td>
          <td>
            Selected Operand Size<br>
            00: 8 bits<br>
            01: 16 bits<br>
            10: 32 bits<br>
            11: 64 bits
          </td>
        </tr>
        <tr>
          <td>MM</td>
          <td>
            Selected Math Mode<br>
            00 = Integer<br>
            01 = Fractional<br>
            10 = Fixed Point<br>
            11 = Floating Point<br>
            <br>
            The math mode only affects ADC, SBB, MUL, DIV, and CMP.<br>
            <br>
            Integer Mode:<br>
            Carry and Overflow are (un)signed carry and overflow.<br>
            For DIV, the quotient and remainder are stored in the selected register and complement.<br>
            For MUL, the result is twice as many bits.<br>
            For 64-bit MUL, the 128-bit product is split across (R0, R1) or (R2, R3), where R0 or R2 is highest 64 bits.<br>
            Highest bit is sign bit if using signed math.<br>
            <br>
            Fractional Mode:<br>
            A register is split into numerator (upper half) and denominator (lower half).<br>
            Numerator highest bit is sign bit if using signed math.<br> 
            Denominator is always unsigned.<br>
            If operand size is 8 bits, a 16 bit value is used.<br>
            Otherwise operates like Integer Mode.<br>
            <br>
            Fixed Point Mode:<br>
            Scaling factor and min/max range limited to decimal values:<br>
            16 bits: scaling factor = 10^-2, range = +/-99.99.<br>
            32 bits: scaling factor = 10^-4, range = +/-99,999.9999.<br>
            64 bits: scaling factor = 10^-8, range = +/-99,999,999,999.99999999.<br>
            If operand size is 8 bits, a 16 bit value is used.<br>
            Otherwise operates like Integer Mode.<br>
            <br>
            Floating Point Mode:<br>
            Carry = NaN.<br>
            Overflow = Divide By Zero.<br>
            ZN have usual meaning.<br>
            No unsigned math.<br>
            Implemented as IEEE 754 Half Precision (16 bits), Single Precision (32 bits), or Double Precision (64 bits).<br>
            If operand size is 8 bits, a 16 bit value is used.
          </td>
        </tr>
      </tbody>
    </table>
    
    <h2>Instructions</h2>
    <ul>
      <li>R = Selected general purpose register</li>
      <li>Rc = Complement of selected general purpose register</li>
      <li>Rx, Ry is either R0, R1 or R2, R3</li>
      <li>PTR = Selected pointer register</li>
      <li>*PTR = Selected pointer register data in current addressing mode</li>
      <li>OFS = Selected offset register</li>
      <li>IX = Selected index register</li>
      <li>IS = Selected index step register</li>
      <li>CTR = Selected counter register</li>
      <li>CS = Selected counter step register</li>
      <li>OP1,OP2 = Operands of last CMP instruction</li>
      <li>Ir = Input register or data</li>
      <li>Or = Output register</li>
      <li>U,S,O = (U)n(S)igned (O)perand of current size</li>
      <li>U8,U16,U32,U64,S8,S16,S32,S64 = (U)n(S)signed operand of specific size</li>
      <li>H = Highest bit, depends on operand size (bit 7, 15, 31, or 63)</li>
      <li>An apostrophe indicates the value after the instruction has executed</li>
    </ul>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Description</th>
          <th>Modes</th>
          <th>Status flags</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td colspan="4">Binary (<span class="count-ins0-binary"></span> opcodes)</td>
        </tr>
        <tr>
          <td>ADD</td>
          <td>Add with carry</td>
          <td>
            R = R + Rc + C<br>
            R = R + *PTR + C<br>
            C = 1 if (H(Or) = 1 or H(Ir) = 1) and (H(Or + Ir + C) = 0)<br>
            V = 1 if (H(Or) = H(Ir)) and (H(Or) != H(Or + Ir + C))
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>AND</td>
          <td>Bitwise AND</td>
          <td>
            R = R ∧ Rc<br>
            R = R ∧ *PTR
          </td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td>CMP</td>
          <td>Compare</td>
          <td>
            CMP R, Rc<br>
            CMP R, *PTR<br>
            C = 1 if R &gt;= Rc/*PTR unsigned<br>
            V = 1 if R &gt;= Rc/*PTR signed<br>
            Z = 1 if R = Rc/*PTR
          </td>
          <td>CVZ----- --------</td>
        </tr>
        <tr>
          <td>DIV</td>
          <td>Division</td>
          <td>
            R' = R / Rc; Rc' = R mod Rc<br>
            R' = R / *PTR; Rc' = R mod *PTR<br>
            C and V are only set in floating point mode<br>
            If denominator is zero:<br>
            If math mode is floating point, result is +/- infinity,<br>
            else execute *FFFFFFFC interrupt with R0 = 3 (division by zero)
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>MUL</td>
          <td>Multiply</td>
          <td>
            When OO = 00, 01, or 10:<br>
            R = R * Rc<br>
            R = R * *PTR<br>
            When OO = 11:<br>
            Rx, Ry = R * Rc<br>
            Rx, Ry = R * *PTR<br>
            Rx is upper 64 bits, Ry is lower 64 bits<br>
            C = 1 if (H(Or) = 1 or H(Ir) = 1) and (H(Or + Ir + C) = 0)<br>
            V = 1 if (H(Or) = H(Ir)) and (H(Or) != H(Or + Ir + C))
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>OR</td>
          <td>Bitwise OR</td>
          <td>
            R = R ∨ Rc<br>
            R = R ∨ *PTR
          </td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td>SHA</td>
          <td>Shift bits right, arithmetic</td>
          <td>
            R = R &gt;&gt; Rc<br>
            R = R &gt;&gt; U8<br>
            Highest Rc bits of R &gt;&gt; Rc = H(R), causing the sign of R to remain the same<br>
            C = 1 if any of the lower Rc bits of R are set
          </td>
          <td>C-ZN---- --------</td>
        </tr>
        <tr>
          <td>SHL</td>
          <td>Shift bits left</td>
          <td>
            R = R &lt;&lt; Rc<br>
            R = R &lt;&lt; U8<br>
            C = 1 if any of the upper Rc bits of R are set
          </td>
          <td>C-ZN---- --------</td>
        </tr>
        <tr>
          <td>SHR</td>
          <td>Shift bits right</td>
          <td>
            R = R &gt;&gt; Rc<br>
            R = R &gt;&gt; U8<br>
            C = 1 if any of the lower Rc bits of R are set
          </td>
          <td>C-ZN---- --------</td>
        </tr>
        <tr>
          <td>SUB</td>
          <td>Subtract with borrow</td>
          <td>
            R = R - Rc - C<br>
            R = R - *PTR - C<br>
            C = 1 if (Rc/*PTR + C) > Or unsigned<br>
            V = 1 if (H(Or) != H(Ir)) and (H(Rc/*PTR) = H(R - Rc/*PTR - C))<br>
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>TCLR</td>
          <td>Test bits clear</td>
          <td>
            R = pattern to test, Rc = value to test<br>
            R = pattern to test, *PTR = value to test<br>
            Z = 1 if every bit set in R is clear in Rc/*PTR
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>TSET</td>
          <td>Test bits set</td>
          <td>
            R = pattern to test, Rc = value to test<br>
            R = pattern to test, *PTR = value to test<br>
            Z = 1 if every bit set in R is set in Rc/*PTR
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>XOR</td>
          <td>Bitwise XOR</td>
          <td>
            R = R ⊻ Rc<br>
            R = R ⊻ *PTR
          </td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td colspan="4">Branch and Jump (<span class="count-ins0-branch"></span> opcodes)</td>
        </tr>
        <tr>
          <td>BCC (BLTU, BNANC)</td>
          <td>Branch on carry clear (Op1 &lt; Op2 unsigned, FP result is not NaN)</td>
          <td>
            PC = PC + S8 if C = 0
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BCS (BGEU, BNANS)</td>
          <td>Branch on carry set (Op1 &gt;= Op2 unsigned, FP result is NaN)</td>
          <td>
            PC = PC + S8 if C = 1
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BEQ</td>
          <td>Branch on equal to zero (Op1 = Op2)</td>
          <td>
            PC = PC + S8 if Z = 1
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BMI</td>
          <td>Branch on negative</td>
          <td>
            PC = PC + S8 if N = 1
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BNE</td>
          <td>Branch on not equal to zero (Op1 != Op2)</td>
          <td>
            PC = PC + S8 if Z = 0
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BPL</td>
          <td>Branch on positive (or zero)</td>
          <td>
            PC = PC + S8 if N = 0
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BVC (BLTS, BDZC)</td>
          <td>Branch on overflow clear (Op1 &lt; Op2 signed, Divide by zero clear)</td>
          <td>
            PC = PC + S8 if V = 0
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>BVS (BGES, BDZS)</td>
          <td>Branch on overflow set (Op1 &gt;= Op2 signed, Divide by zero set)</td>
          <td>
            PC = PC + S8 if V = 1
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>JMA</td>
          <td>Jump to an absolute unsigned address</td>
          <td>
            PC = R<br>
            PC = U32
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>JMP</td>
          <td>Jump to relative signed address</td>
          <td>
            PC = PC + R<br>
            PC = PC + S16
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>JSA</td>
          <td>Jump to subroutine at an absolute unsigned address</td>
          <td>
            Push PC; PC = R<br>
            Push PC; PC = U32
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>JSR</td>
          <td>Jump to subroutine at a relative signed address</td>
          <td>
            Push PC; PC = PC + R<br>
            Push PC; PC = PC + S16
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>RTI</td>
          <td>Return from interrupt</td>
          <td>
            PUL R0<br>
            PUL R1<br>
            PUL R2<br>
            PUL R3<br>
            PUL PTR0<br>
            PUL OFS0<br>
            PUL IX0<br>
            PUL IS0<br>
            PUL PTR1<br>
            PUL OFS1<br>
            PUL IX1<br>
            PUL IS1<br>
            PUL CTR0<br>
            PUL CS0<br>
            PUL CTR1<br>
            PUL CS1br>
            Pull PC<br>
            Pull ST<br>
            A hardware error occurs if the stack underflows
          </td>
          <td>CVZNAAAI RRPTOOMM</td>
        </tr>
        <tr>
          <td>RTS</td>
          <td>Return from subroutine</td>
          <td>
            Pull PC<br>
            SP = SP + U8; Pull PC<br>
            A hardware error occurs if the stack underflows
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td colspan="4">Floating Point (<span class="count-ins0-float"></span> opcodes)</td>
        </tr>
        <tr>
          <td>F2SF</td>
          <td>Signed integer to floating point</td>
          <td>
            R(floating point) = R(signed int)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FABS</td>
          <td>Absolute value</td>
          <td>
            R = ABS(R)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FACS</td>
          <td>Arc cosine</td>
          <td>
            R = ARCCOS(Rc)
          </td>
          <td>--Z---- --------</td>
        </tr>
        <tr>
          <td>FASN</td>
          <td>Arc sine</td>
          <td>
            R = ARCSIN(Rc)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FATN</td>
          <td>Arc tangent</td>
          <td>
            R = ARCTAN(Rc)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FCEL</td>
          <td>Ceiling</td>
          <td>
            R = CEIL(R)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FCOS</td>
          <td>Cosine</td>
          <td>
            R = COS(Rc)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FF2S</td>
          <td>Floating point to signed integer</td>
          <td>
            R(signed int) = R(floating point)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FF2U</td>
          <td>Floating point to unsigned integer</td>
          <td>
            R(unsigned int) = R(floating point)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FFLR</td>
          <td>Floor</td>
          <td>
            R = FLOOR(R)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FLOG</td>
          <td>Logarithm base 10</td>
          <td>
            R = LOG10(Rc)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FNLG</td>
          <td>Logarithm base E</td>
          <td>
            R = LOGE(Rc)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FPOW</td>
          <td>Power</td>
          <td>
            R = R ^ Rc
          </td>
          <td>-VZN--- --------</td>
        </tr>
        <tr>
          <td>FSIN</td>
          <td>Sine</td>
          <td>
            R = SIN(Rc)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FSQR</td>
          <td>Square root</td>
          <td>
            R = √Rc
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FTAN</td>
          <td>Tangent</td>
          <td>
            R = TAN(Rc)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td>FU2F</td>
          <td>Unsigned integer to floating point</td>
          <td>
            R(floating point) = R(unsigned int)
          </td>
          <td>--ZN--- --------</td>
        </tr>
        <tr>
          <td colspan="4">Move and swap (<span class="count-ins0-move"></span> opcodes)</td>
        </tr>
        <tr>
          <td>MOV</td>
          <td>Move data</td>
          <td>
            MOV R,PTR<br>
            MOV PTR,R<br>
            MOV R,*PTR<br>
            MOV *PTR,R<br>
            MOV R,*SP[U8]<br>
            MOV *SP[U8],R<br>
            MOV R,O
          </td>
          <td>
            --ZN---- --------<br>
          </td>
        </tr>
        <tr>
          <td>SWP</td>
          <td>Swap data</td>
          <td>
            SWP R,Rc<br>
            SWP R,PTR<br>
            SWP R,*PTR<br>
            SWP R,OFS<br>
            SWP R,IX<br>
            SWP R,IS<br>
            SWP R,CTR<br>
            SWP R,CS<br>
            SWP R,ST<br>
            SWP R,SB<br>
            SWP R,*SP[U8]<br>
            SWP R,M
          </td>
          <td>
            --ZN---- --------<br>
          </td>
        </tr>
        <tr>
          <td colspan="4">Other (<span class="count-ins0-other"></span> opcodes)</td>
        </tr>
        <tr>
          <td>NOP</td>
          <td>No operation</td>
          <td>Waste a CPU cycle</td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td colspan="4">Stack (<span class="count-ins0-stack"></span> opcodes)</td>
        </tr>
        <tr>
          <td>PSH</td>
          <td>Push on the stack</td>
          <td>
            If SP - register size &lt; 0 execute *FFFFFFFC interrupt with R0 = 1 (stack overflow)<br>
            *SP = register<br>
            SP = SP - register size<br>
            <br>
            PSH R0<br>
            PSH R1<br>
            PSH R2<br>
            PSH R3<br>
            PSH PTR0<br>
            PSH OFS0<br>
            PSH IX0<br>
            PSH IS0<br>
            PSH PTR1<br>
            PSH OFS1<br>
            PSH IX1<br>
            PSH IS1<br>
            PSH CTR0<br>
            PSH CS0<br>
            PSH CTR1<br>
            PSH CS1<br>
            PSH ST<br>
          </td>
          <td>-------- --------</td>
        </tr>
        <tr>
          <td>PUL</td>
          <td>Pull off the stack</td>
          <td>
            If SP + register size &gt; FFFFFFFF execute *FFFFFFFC interrupt with R0 = 2 (stack underflow)<br>
            SP = SP + register size<br>
            register = *SP<br>
            <br>
            PUL R0<br>
            PUL R1<br>
            PUL R2<br>
            PUL R3<br>
            PUL PTR0<br>
            PUL OFS0<br>
            PUL IX0<br>
            PUL IS0<br>
            PUL PTR1<br>
            PUL OFS1<br>
            PUL IX1<br>
            PUL IS1<br>
            PUL CTR0<br>
            PUL CS0<br>
            PUL CTR1<br>
            PUL CS1<br>
            PUL ST<br>
          </td>
          <td>
            ------- --------<br>
            Except PUL ST which affects all flags
          </td>
        </tr>
        <tr>
          <td>SSP</td>
          <td>Subtract from stack pointer</td>
          <td>
            If SP - U8 &lt; 0 execute *FFFFFFFC interrupt with R0 = 1 (stack overflow)<br>
            SP = SP - U8
          </td>
          <td>--------- --------</td>
        </tr>
        <tr>
          <td colspan="4">Status (<span class="count-ins0-status"></span> opcodes)</td>
        </tr>
        <tr>
          <td>CLC</td>
          <td>Clear carry flag (Clear NaN)</td>
          <td>Set C = 0</td>
          <td>C------- --------</td>
        </tr>
        <tr>
          <td>CLI</td>
          <td>Clear interrupt disable flag</td>
          <td>Set I = 0</td>
          <td>-------I --------</td>
        </tr>
        <tr>
          <td>SEA0</td>
          <td>Select address mode 0</td>
          <td>Set AAA = 0</td>
          <td>----000- --------</td>
        </tr>
        <tr>
          <td>SEA1</td>
          <td>Select address mode 1</td>
          <td>Set AAA = 1</td>
          <td>----001- --------</td>
        </tr>
        <tr>
          <td>SEA2</td>
          <td>Select address mode 2</td>
          <td>Set AAA = 2</td>
          <td>----010- --------</td>
        </tr>
        <tr>
          <td>SEA3</td>
          <td>Select address mode 3</td>
          <td>Set AAA = 3</td>
          <td>----011- --------</td>
        </tr>
        <tr>
          <td>SEA4</td>
          <td>Select address mode 4</td>
          <td>Set AAA = 4</td>
          <td>----100- --------</td>
        </tr>
        <tr>
          <td>SEA5</td>
          <td>Select address mode 5</td>
          <td>Set AAA = 5</td>
          <td>----101- --------</td>
        </tr>
        <tr>
          <td>SEA6</td>
          <td>Select address mode 6</td>
          <td>Set AAA = 6</td>
          <td>----110- --------</td>
        </tr>
        <tr>
          <td>SEA7</td>
          <td>Select address mode 7</td>
          <td>Set AAA = 7</td>
          <td>----111- --------</td>
        </tr>
        <tr>
          <td>SEC</td>
          <td>Set carry flag (Set NaN)</td>
          <td>Set C = 1</td>
          <td>C------- --------</td>
        </tr>
        <tr>
          <td>SEI</td>
          <td>Set interrupt disable flag</td>
          <td>Set I = 1</td>
          <td>-------I --------</td>
        </tr>
        <tr>
          <td>SEM0</td>
          <td>Select math mode 0</td>
          <td>Set MM = 0</td>
          <td>-------- ------00</td>
        </tr>
        <tr>
          <td>SEM1</td>
          <td>Select math mode 1</td>
          <td>Set MM = 1</td>
          <td>-------- ------01</td>
        </tr>
        <tr>
          <td>SEM2</td>
          <td>Select math mode 2</td>
          <td>Set MM = 2</td>
          <td>-------- ------10</td>
        </tr>
        <tr>
          <td>SEM3</td>
          <td>Select math mode 3</td>
          <td>Set MM = 3</td>
          <td>-------- ------11</td>
        </tr>
        <tr>
          <td>SEO0</td>
          <td>Select operand size 0 (8 bits)</td>
          <td>Set OO = 0</td>
          <td>-------- ----00--</td>
        </tr>
        <tr>
          <td>SEO1</td>
          <td>Select operand size 1 (16 bits)</td>
          <td>Set OO = 1</td>
          <td>-------- ----01--</td>
        </tr>
        <tr>
          <td>SEO2</td>
          <td>Select operand size 2 (32 bits)</td>
          <td>Set OO = 2</td>
          <td>-------- ----10--</td>
        </tr>
        <tr>
          <td>SEO3</td>
          <td>Select operand size 3 (64 bits)</td>
          <td>Set OO = 3</td>
          <td>-------- ----11--</td>
        </tr>
        <tr>
          <td>SEPS0</td>
          <td>Select pointer set 0</td>
          <td>Set P = 0</td>
          <td>-------- --0-----</td>
        </tr>
        <tr>
          <td>SEPS1</td>
          <td>Select pointer set 1</td>
          <td>Set P = 1</td>
          <td>-------- --1-----</td>
        </tr>
        <tr>
          <td>SER0</td>
          <td>Select R0</td>
          <td>Set RR = 0</td>
          <td>-------- 00------</td>
        </tr>
        <tr>
          <td>SER1</td>
          <td>Select R1</td>
          <td>Set RR = 1</td>
          <td>-------- 01------</td>
        </tr>
        <tr>
          <td>SER2</td>
          <td>Select R2</td>
          <td>Set RR = 2</td>
          <td>-------- 10------</td>
        </tr>
        <tr>
          <td>SER3</td>
          <td>Select R3</td>
          <td>Set RR = 3</td>
          <td>-------- 11------</td>
        </tr>
        <tr>
          <td>SET0</td>
          <td>Select counter set 0</td>
          <td>Set T = 0</td>
          <td>-------- ---0----</td>
        </tr>
        <tr>
          <td>SET1</td>
          <td>Select counter set 1</td>
          <td>Set T = 1</td>
          <td>-------- ---1----</td>
        </tr>
        <tr>
          <td colspan="4">Unary (<span class="count-ins0-unary"></span> opcodes)</td>
        </tr>
        <tr>
          <td>DEC</td>
          <td>Decrement</td>
          <td>
            R = R - 1<br>
            *PTR = *PTR -1<br>
            C = 1 if H(R/*PTR) = 0 and (H'(R/*PTR) = 1)<br>
            V = 1 if (H(R/*PTR) = 1) and (H'(R/*PTR) = 0)<br>
            Only the Zero flag is set for counters
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>INC</td>
          <td>Increment</td>
          <td>
            R = R + 1<br>
            *PTR = *PTR + 1<br>
            C = 1 if (H(R/*PTR) = 1) and (H'(R/*PTR) = 0)<br>
            V = 1 if (H(R/*PTR) = 0) and (H'(R/*PTR) = 1)<br>
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>NEG</td>
          <td>Negate</td>
          <td>
            R = -R<br>
            *PTR = -*PTR
          </td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td>NG1</td>
          <td>Set to -1</td>
          <td>
            R = -1<br>
            *PTR = -1 (current operand size)<br>
            IS = -1
          </td>
          <td>--ZN----- --------</td>
        </tr>
        <tr>
          <td>NOT</td>
          <td>Bitwise NOT</td>
          <td>
            R = ~R<br>
            *PTR = ~*PTR
          </td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td>NXT</td>
          <td>Add step to register</td>
          <td>
            IX = IX + IS<br>
            CTR = CTR - CS<br>
            CVZN are set the same as for ADD/SUB
          </td>
          <td>CVZN---- --------</td>
        </tr>
        <tr>
          <td>ONE</td>
          <td>Set to 1</td>
          <td>
            R = 1<br>
            IS = 1<br>
            CS = 1
          </td>
          <td>--ZN---- --------</td>
        </tr>
        <tr>
          <td>SHAC</td>
          <td>Arithmetic shift right with carry</td>
          <td>
            R = R &gt;&gt; 1<br>
            H'(R) = H(R)<br>
            C = BIT0(R)
          </td>
          <td>C-ZN--- --------</td>
        </tr>
        <tr>
          <td>SHLC</td>
          <td>Shift left with carry</td>
          <td>
            R = R &lt;&lt; 1<br>
            BIT0(R) = C<br>
            C = H(R)
          </td>
          <td>C-ZN--- --------</td>
        </tr>
        <tr>
          <td>SHRC</td>
          <td>Shift right with carry</td>
          <td>
            R = R &gt;&gt; 1<br>
            H(R) = C<br>
            C = BIT0(R)
          </td>
          <td>C-ZN--- --------</td>
        </tr>
        <tr>
          <td>ZRO</td>
          <td>Set to 0</td>
          <td>
            R = 0<br>
            IX = 0
          </td>
          <td>--ZN---- --------</td>
        </tr>
      </tbody>
    </table>
    
    <h2>Branches and Jumps</h2>
    <p>
      All relative branches and jumps are relative to the address of the first byte of the next instruction.
      Branches use 8-bit operands, while jumps use 16-bit operands.
      Relative to the first byte of the branch itself, the 8-bit operand allows a jump in the range of [-126, 129],
      while a 16-bit operand allows a jump in the range of [-32765, 32770].
    </p>
    <p>
      JMA/JSA Allow jumps with an absolute 32-bit usigned address to any code in the system.
    </p>
    
    <h2>Interrupts</h2>
    <ul>
      <li>Interrupts can only occur by hardware, there is no instruction to invoke an interrupt.</li>
      <li>Interrupts can only occur when the Interrupt Disabled flag is clear. Any routine should set this flag
        at the start of a critical section, and clear it at the end.
      </li>
      <li>Interrupts save all registers and must end with an RTI instruction to pull all registers and resume
        execution at the interrupted code.
      </li>
      <li>Interrupts need a defined memory address to contain the pointer to the interrupt routine.
        An optional interrupt begins with the pointer set to 0, a required interrupt will
        initialize the pointer to a default routine. 
      </li>
    </ul>
    
    <h2>General Information</h2>
    <ol>
      <li>The processor is little endian - the highest byte is stored first, the lowest byte last</li>
      <li>The stack is 64k in size, the default range = FFFE0000 thru FFFEFFFF</li>
      <li>OS routines should be located in FFFF0000 thru FFFFFFFB</li>
      <li>Reset/error interrupt pointer is FFFFFFFC thru FFFFFFFF</li>
      <li>Since there is no software interrupt instruction, use JSA to call an address containing a JMA instruction that
        calls the actual routine at an OS defined address. Such a jump table provides well-known addresses for users to
        call OS routines, while allowing the OS routines to be moved around as they are updated.
      </li>
    </ol>
    
    <h2>Startup information</h2>
    <ul>
      <li>A reset executes *FFFFFFFC interrupt with R0 = 0.</li>
      <li>All other registers have undefined values on reset. A reset could occur at anytime, in which case the registers will
        still hold their current values after the reset.
      </li>
      <li>This same interrupt has other values for R0 for error conditions (see Instructions)</li>
    </ul>
    
    <h2>Opcodes</h2>
    <ul>
      <li>All unused opcodes in columns 0 thru B are reserved for future use.</li>
      <li>All opcodes in columns C thru F are available for implementation use.</li>
      <li>Opcodes cannot be user defined.</li>
    </ul>
    <p>Legend</p>
    <p>Note: roll mouse over the colours in the legend to highlight the instructions in the table.</p>
    <table id="legend0">
      <thead>
        <tr>
          <th>Instruction Group</th>
          <th>Opcodes</th>
          <th>Colour</th>
          <th>Instruction Group</th>
          <th>Opcodes</th>
          <th>Colour</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Binary</td>
          <td><span class="count-ins0-binary"></span></td>
          <td class="ins0-binary"></td>
          
          <td>Branch and Jump</td>
          <td><span class="count-ins0-branch"></span></td>
          <td class="ins0-branch"></td>
        </tr>
        <tr>
          <td>Move and swap</td>
          <td><span class="count-ins0-move"></span></td>
          <td class="ins0-move"></td>
          
          <td>Other</td>
          <td><span class="count-ins0-other"></span></td>
          <td class="ins0-other"></td>
        </tr>
        <tr>
          <td>Pointer</td>
          <td><span class="count-ins0-float"></span></td>
          <td class="ins0-float"></td>          
          
          <td>Stack</td>
          <td><span class="count-ins0-stack"></span></td>
          <td class="ins0-stack"></td>
        </tr>
        <tr>                    
          <td>Status</td>
          <td><span class="count-ins0-status"></span></td>
          <td class="ins0-status"></td>
          
          <td>Unary</td>
          <td><span class="count-ins0-unary"></span></td>
          <td class="ins0-unary"></td>
        </tr>
      </tbody>
    </table>
    
    <p>Opcodes</p>
    <table id="opcodes">
      <thead>
        <tr>
          <th></th>
          <th>0</th>
          <th>1</th>
          <th>2</th>
          <th>3</th>
          <th>4</th>
          <th>5</th>
          <th>6</th>
          <th>7</th>
          <th>8</th>
          <th>9</th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
          <th>D</th>
          <th>E</th>
          <th>F</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td class="ins0-binary">ADD R,Rc</td>
          <td class="ins0-binary">ADD R,*PTR</td>
          <td class="ins0-binary">AND R,Rc</td>
          <td class="ins0-binary">AND R,*PTR</td>
          <td class="ins0-binary">CMP R,Rc</td>
          <td class="ins0-binary">CMP R,*PTR</td>
          <td class="ins0-binary">DIV R,Rc</td>
          <td class="ins0-binary">DIV R,*PTR</td>
          <td class="ins0-binary">MUL R,Rc</td>
          <td class="ins0-binary">MUL R,*PTR</td>
          <td class="ins0-binary">OR R,Rc</td>
          <td class="ins0-binary">OR R,*PTR</td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          
        </tr>
        <tr>
          <th>1</th>
          <td class="ins0-binary">SHA R,Rc</td>
          <td class="ins0-binary">SHA R,U8</td>
          <td class="ins0-binary">SHL R,Rc</td>
          <td class="ins0-binary">SHL R,U8</td>
          <td class="ins0-binary">SHR R,Rc</td>
          <td class="ins0-binary">SHR R,U8</td>
          <td class="ins0-binary">SUB R,Rc</td>
          <td class="ins0-binary">SUB R,*PTR</td>
          <td class="ins0-binary">TCLR R,Rc</td>
          <td class="ins0-binary">TCLR R,*PTR</td>
          <td class="ins0-binary">TSET R,Rc</td>
          <td class="ins0-binary">TSET R,*PTR</td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>

        </tr>
        <tr>
          <th>2</th>
          <td class="ins0-binary">XOR R,Rc</td>
          <td class="ins0-binary">XOR R,*PTR</td>
          <td class="ins0-branch">BCC S8</td>
          <td class="ins0-branch">BCS S8</td>
          <td class="ins0-branch">BEQ S8</td>
          <td class="ins0-branch">BMI S8</td>
          <td class="ins0-branch">BNE S8</td>
          <td class="ins0-branch">BPL S8</td>
          <td class="ins0-branch">BVC S8</td>
          <td class="ins0-branch">BVS S8</td>
          <td class="ins0-branch">JMA R</td>
          <td class="ins0-branch">JMA U32</td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
        <tr>
          <th>3</th>
          <td class="ins0-branch">JMP R</td>
          <td class="ins0-branch">JMP S16</td>
          <td class="ins0-branch">JSA R</td>
          <td class="ins0-branch">JSA U32</td>
          <td class="ins0-branch">JSR R</td>
          <td class="ins0-branch">JSR S16</td>
          <td class="ins0-branch">RTI</td>
          <td class="ins0-branch">RTS</td>
          <td class="ins0-branch">RTS U8</td>
          <td class="ins0-float">F2SF</td>
          <td class="ins0-float">FABS</td>
          <td class="ins0-float">FACS</td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
        <tr>
          <th>4</th>
          <td class="ins0-float">FASN</td>
          <td class="ins0-float">FATN</td>
          <td class="ins0-float">FCEL</td>
          <td class="ins0-float">FCOS</td>
          <td class="ins0-float">FF2S</td>
          <td class="ins0-float">FF2U</td>
          <td class="ins0-float">FFLR</td>
          <td class="ins0-float">FLOG</td>
          <td class="ins0-float">FNLG</td>
          <td class="ins0-float">FPOW</td>
          <td class="ins0-float">FSIN</td>
          <td class="ins0-float">FSQR</td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
        <tr>
          <th>5</th>
          <td class="ins0-float">FTAN</td>
          <td class="ins0-float">FU2F</td>
          <td class="ins0-move">MOV R,PTR</td>
          <td class="ins0-move">MOV PTR,R</td>
          <td class="ins0-move">MOV R,*PTR</td>
          <td class="ins0-move">MOV *PTR,R</td>
          <td class="ins0-move">MOV R,*SP[U8]</td>
          <td class="ins0-move">MOV *SP[U8],R</td>
          <td class="ins0-move">MOV R,O</td>
          <td class="ins0-move">SWP R,Rc</td>
          <td class="ins0-move">SWP R,PTR</td>
          <td class="ins0-move">SWP R,*PTR</td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
        <tr>
          <th>6</th>
          <td class="ins0-move">SWP R,OFS</td>
          <td class="ins0-move">SWP R,IX</td>
          <td class="ins0-move">SWP R,IS</td>
          <td class="ins0-move">SWP R,CTR</td>
          <td class="ins0-move">SWP R,CS</td>
          <td class="ins0-move">SWP R,ST</td>
          <td class="ins0-move">SWP R,SB</td>
          <td class="ins0-move">SWP R,*SP[U8]</td>
          <td class="ins0-move">SWP R,M</td>
          <td class="ins0-other">NOP</td>
          <td class="ins0-stack">PSH R0</td>
          <td class="ins0-stack">PSH R1</td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
        <tr>
          <th>7</th>
          <td class="ins0-stack">PSH R2</td>
          <td class="ins0-stack">PSH R3</td>
          <td class="ins0-stack">PSH PTR0</td>
          <td class="ins0-stack">PSH OFS0</td>
          <td class="ins0-stack">PSH IX0</td>
          <td class="ins0-stack">PSH IS0</td>
          <td class="ins0-stack">PSH PTR1</td>
          <td class="ins0-stack">PSH OFS1</td>
          <td class="ins0-stack">PSH IX1</td>
          <td class="ins0-stack">PSH IS1</td>
          <td class="ins0-stack">PSH CTR0</td>
          <td class="ins0-stack">PSH CS0</td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
        <tr>
          <th>8</th>
          <td class="ins0-stack">PSH CTR1</td>
          <td class="ins0-stack">PSH CS1</td>
          <td class="ins0-stack">PSH ST</td>
          <td class="ins0-stack">PUL R0</td>
          <td class="ins0-stack">PUL R1</td>
          <td class="ins0-stack">PUL R2</td>
          <td class="ins0-stack">PUL R3</td>
          <td class="ins0-stack">PUL PTR0</td>
          <td class="ins0-stack">PUL OFS0</td>
          <td class="ins0-stack">PUL IX0</td>
          <td class="ins0-stack">PUL IS0</td>
          <td class="ins0-stack">PUL PTR1</td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
        <tr>
          <th>9</th>
          <td class="ins0-stack">PUL OFS1</td>
          <td class="ins0-stack">PUL IX1</td>
          <td class="ins0-stack">PUL IS1</td>
          <td class="ins0-stack">PUL CTR0</td>
          <td class="ins0-stack">PUL CS0</td>
          <td class="ins0-stack">PUL CTR1</td>
          <td class="ins0-stack">PUL CS1</td>
          <td class="ins0-stack">PUL ST</td>
          <td class="ins0-stack">SSP U8</td>
          <td class="ins0-status">CLC</td>
          <td class="ins0-status">CLI</td>
          <td class="ins0-status">SEA0</td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
        <tr>
          <th>A</th>
          <td class="ins0-status">SEA1</td>
          <td class="ins0-status">SEA2</td>
          <td class="ins0-status">SEA3</td>
          <td class="ins0-status">SEA4</td>
          <td class="ins0-status">SEA5</td>
          <td class="ins0-status">SEA6</td>
          <td class="ins0-status">SEA7</td>
          <td class="ins0-status">SEC</td>
          <td class="ins0-status">SEI</td>
          <td class="ins0-status">SEM0</td>
          <td class="ins0-status">SEM1</td>
          <td class="ins0-status">SEM2</td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
        <tr>
          <th>B</th>
          <td class="ins0-status">SEM3</td>
          <td class="ins0-status">SEO0</td>
          <td class="ins0-status">SEO1</td>
          <td class="ins0-status">SEO2</td>
          <td class="ins0-status">SEO3</td>
          <td class="ins0-status">SEPS0</td>
          <td class="ins0-status">SEPS1</td>
          <td class="ins0-status">SER0</td>
          <td class="ins0-status">SER1</td>
          <td class="ins0-status">SER2</td>
          <td class="ins0-status">SER3</td>
          <td class="ins0-status">SET0</td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
        <tr>
          <th>C</th>
          <td class="ins0-status">SET1</td>
          <td class="ins0-unary">DEC R</td>
          <td class="ins0-unary">DEC *PTR</td>
          <td class="ins0-unary">INC R</td>
          <td class="ins0-unary">INC *PTR</td>
          <td class="ins0-unary">NEG R</td>
          <td class="ins0-unary">NEG *PTR</td>
          <td class="ins0-unary">NG1 R</td>
          <td class="ins0-unary">NG1 *PTR</td>
          <td class="ins0-unary">NG1 IS</td>
          <td class="ins0-unary">NOT R</td>
          <td class="ins0-unary">NOT *PTR</td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
        <tr>
          <th>D</th>
          <td class="ins0-unary">NXT IX</td>
          <td class="ins0-unary">NXT CTR</td>
          <td class="ins0-unary">ONE R</td>
          <td class="ins0-unary">ONE IS</td>
          <td class="ins0-unary">ONE CS</td>
          <td class="ins0-unary">SHAC R</td>
          <td class="ins0-unary">SHLC R</td>
          <td class="ins0-unary">SHRC R</td>
          <td class="ins0-unary">ZRO R</td>
          <td class="ins0-unary">ZRO IX</td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
        <tr>
          <th>E</th>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
        <tr>
          <th>F</th>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
          <td class="ins0-"></td>
        </tr>
      </tbody>
    </table>
  </body>
</html>
